NAMESPACE EM_OutVlv
TYPE OutVlv_inputs
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      outletVlv_isOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outlet valve is open
      outletVlv_isClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outlet valve is closed
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_Initialize_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      initialized { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Equipment Module Initialized
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_OpenOutlet_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      waitingOutletOpenDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delay before opening the outlet valve
      outletOpened { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outlet valve is open
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_StartVacuum_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      waitingAhuMinAirflow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Waiting for AHU to reach the minimum required airflow.
      buildingUpVacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vacuum is building up to operational pressure.
      vacuumOperationReady { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vacuum system is fully ready and operational.
      startingVacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vacuum is being started
      minAirflowReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Minimum airflow confirmed.
      minTimeLineEmptyReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_StopVacuum_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      waitingIsolationVlvCloseDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delay before closing the isolation valve.
      waitingVacuumVlvCloseDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delay before closing the vacuum valve.
      stoppingVacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vacuum is being stopped
      vacuumStopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vacuum system is fully stopped.
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_Initialize_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      initialized { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Equipment Module Initialized
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_CloseOutlet_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      waitingOutletCloseDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delay before closing the outlet valve
      outletClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outlet valve is closed
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_Purge_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      purging { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Purge is active
      waitingStartDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start delay is active
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_HoldPosition_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      held { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Held in last position
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE LIB
TYPE Util_Step
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := Util_Step_Constants#RESET_STEP;   // Current step number
      firstCycle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True on first cycle of step
      actualTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Elapsed time in step (ms)
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE LIB
TYPE Util_modeStatus
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the mode is idle (not active)
      done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the mode has completed
      busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the mode is actively executing
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_inputs
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      AHU_minAirflowReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // AHU Minimum airflow reached
      vacuumAirflow_PV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Airflow process value
      vacuumVlv_isOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vacuum valve is open
      vacuumVlv_isClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vacuum valve is closed
      isolationVlv_isOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Isolation valve is open
      isolationVlv_isClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Isolation valve is closed
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_Discharge_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      closingOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_parameters_variable
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      isolationVlvCloseDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 30;   // Isolation Valve: Close delay
      minTimeLineEmpty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_parameters_fixed
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      vacuumMinAirFlow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real := 2.0;   // Vacuum: Minimum vacuum airflow required for proper operation
      vacuumMaxAirFlow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real := 10.0;   // Vacuum: Maximum vacuum airflow during operation
      vacuumBuildUpTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 10;   // Vacuum: Duration of the vacuum buildup
      vacuumVlvCloseDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 5;   // Vacuum Valve: Close delay
      vacuumControlMinOpening { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 0;   // Vacuum Control Valve: Minimum opening position.
      vacuumControlSP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 45;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_StopVacuum_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      isolationVlvCloseDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 5;   // Isolation Valve: Close delay
      vacuumVlvCloseDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 30;   // Vacuum Valve: Close delay
      vacuumControlSP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 45;   // Vacuum Control Valve: Setpoint.
      vacuumControlMinOpening { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 10;   // Vacuum Control Valve: Minimum opening position.
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE LIB
FUNCTION IsTimerExceeded : Bool
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      actualTimer : Time;   // current step timer (Time)
      limit : UInt;   // Time delay parameter (second)
   END_VAR

   VAR CONSTANT 
      MILLIS_PER_SECOND : UDInt := 1000;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // IsTimerExceeded Logic
	    // Description: 
	    // - Checks if actualTimer (ms) exceeds limit (seconds) converted to ms.
	    // - Returns TRUE if elapsed time exceeds threshold, FALSE otherwise.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        VAR         05MAY25     Initial version
	        *)
	    END_REGION
	END_REGION
	
	#IsTimerExceeded := (TIME_TO_UDINT(#actualTimer) > (UINT_TO_UDINT(#limit) * #MILLIS_PER_SECOND));
END_FUNCTION
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_inputs
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      em_vac_inputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.EM_Vac.Vac_inputs;   // EM Vacuum inputs
      em_outVlv_inputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.EM_OutVlv.OutVlv_inputs;   // EM Hopper inputs
      ventVlv_isOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vent valve is open
      ventVlv_isClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vent valve is closed
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_interface_modesStatus
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      initialize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      openOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      closeOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      purge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      discharge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      holdPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_OpenOutlet_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      vlvOpenDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Valve open delay
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_CloseOutlet_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      vlvCloseDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 5;   // Valve Close delay
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_parameters_fixed
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      purgeStartDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 20;   // Purge: start delay
      purgeCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 5;   // Purge: count
      purgeOutletVlvOpenDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 2;   // Purge: Outlet Valve Open delay
      purgeOutletVlvCloseDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 2;   // Purge: Outlet Valve Close delay
      outletVlvOpenDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 1;
      outletVlvCloseDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 5;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_parameters_variable
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      dischargeTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 40;   // Discharge time
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_Purge_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      startDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 10;   // Purse start delay
      count { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 5;   // Purge Count
      outletVlvOpenDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 2;   // Outlet valve: open delay during purge
      outletVlvCloseDelay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 2;   // Outlet valve: open delay during purge
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_Discharge_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      dischargeTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 40;   // Discharge Time
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_HoldPosition_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_StartVacuum_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      minVacuumAirFlow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real := 5.0;   // Minimum vacuum airflow required for proper operation
      vacuumBuildUpTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 30;   // Duration of the vacuum buildup
      vacuumControlSP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 45;   // Vacuum Control Valve: Setpoint.
      vacuumControlMinOpening { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Vacuum Control Valve: Minimum opening position.
      minTimeLineEmpty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt := 2;   // Minimum time for empty the transfer Line
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_interface_modesStatus
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      initialize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      startVacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      stopVacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE LIB
TYPE Util_status
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the process is idle (not running)
      done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the process has completed successfully
      busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when the process is actively running
      stopAlmActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when a stop alarm is active
      abortAlmActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True when an abort alarm is active
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_Vent_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      venting { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Venting
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_Discharge_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      discharging { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // True while product is discharged
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_OpenHopper_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_Evacuate_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_FlowThrough_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_Purge_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_Initialize_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      initialized { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Equipment Module Initialized
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_interface_feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      outletOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outlet valve is open
      openingOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Opening outlet valve
      outletClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outlet valve is closed
      closingOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Closing outlet valve
      held { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Last position
      modes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Modes feedbacks
         initialize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_Initialize_Feedbacks;   // Initialize feedbacks
         openOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_OpenOutlet_Feedbacks;   // Open Outlet feedbacks
         closeOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_CloseOutlet_Feedbacks;   // Close Outlet feedbacks
         purge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_Purge_Feedbacks;   // Purge feedbacks
         discharge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_Discharge_Feedbacks;   // Discharge feedbacks
         holdPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_HoldPosition_Feedbacks;   // Hold position feedbacks
      END_STRUCT;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_interface_feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      isolationVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vacuum active and Isolation valve is open
      modes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Modes feedbacks
         initialize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Vac_Initialize_Feedbacks;   // Initialize feedbacks
         startVacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Vac_StartVacuum_Feedbacks;   // Start Vacuum feedbacks
         stopVacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Vac_StopVacuum_Feedbacks;   // Stop Vacuum feedbacks
      END_STRUCT;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_Hold_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      held { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vacuum stopped and outlet valve in last position
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE LIB
FUNCTION_BLOCK Step
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      forceReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      step : Util_Step;
   END_VAR

   VAR 
      _private { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         prevCycleStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Previous Cycle Step number
         actualCycleCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
         prevSteps { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..Util_Step_Constants#MAX_ARRAY] of Struct
            number { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
            cycleCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
         END_STRUCT;
         stepTimer {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      END_STRUCT;
   END_VAR

   VAR_TEMP 
      t_index : Int;
   END_VAR

   VAR CONSTANT 
      MAX_TIME : Time := T#24D_20H_31M_23S_647MS;
   END_VAR


BEGIN
	REGION Header
	    
	    //********************************************************
	    // Step Control Logic
	    // Description: 
	    // - Resets step when a new mode is detected or forced reset is triggered.
	    // - Tracks the first cycle of the step to manage transitions.
	    // - Maintains a step history in an array for logging or debugging.
	    // - Handles timer updates for step timing control.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        VAR         15MAY25     Initial
	        *)
	    END_REGION
	    
	END_REGION
	
	
	
	// Reset step number if a new mode is detected
	IF #forceReset THEN
	    #step.actual :=  Util_Step_Constants#RESET_STEP;  // Ensures the process starts fresh
	END_IF;
	
	// Detect if this is the first cycle of a new step
	#step.firstCycle := (#step.actual <> #_private.prevCycleStep);
	// Step is considered first cycle if it differs from the previous step
	// or if a force reset is triggered
	
	IF #step.firstCycle THEN
	    // Shift step history array to store the latest step change
	    #t_index := Util_Step_Constants#MAX_ARRAY;
	    WHILE #t_index > 0 DO
	        #_private.prevSteps[#t_index] := #_private.prevSteps[#t_index - 1];
	        #t_index := #t_index - 1;  
	    END_WHILE;
	    
	    #_private.actualCycleCount := 1;    // Reset step cycle count
	ELSE
	    #_private.actualCycleCount += 1;    // Incr step cycle count
	    
	END_IF;
	
	#_private.prevSteps[0].number := #step.actual;
	#_private.prevSteps[0].cycleCount := #_private.actualCycleCount;
	
	// Store the previous step value
	#_private.prevCycleStep := #step.actual;
	
	REGION Timer
	    // Start or continue timing the step unless it's the first cycle
	    #_private.stepTimer(IN := NOT (#step.firstCycle),
	                        PT := #MAX_TIME);
	    
	    #step.actualTimer := #_private.stepTimer.ET;
	    
	END_REGION
	
	
	
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_CloseHopper_Feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_Discharge_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_Purge_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
FUNCTION_BLOCK EM_OutVlv_discharge
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable step transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_Discharge_Params;   // Discharge parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate discharge sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM/EM in position
      mode_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Mode idle or done
   END_VAR

   VAR_OUTPUT 
      cmd_modeOpenOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Mode Cmd Open Outlet
      cmd_modeCloseOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Mode Cmd Close Outlet
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_Discharge_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_Discharge_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_Discharge_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_OutVlv_discharge Logic
	    // Description: 
	    // - Manages the discharge sequence for the outlet valve, opening and closing the valve to unload product.
	    //********************************************************
	        
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	    
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active   
	            OutVlv_Discharge_Steps#INITIAL:
	                #_stepTracker.next := OutVlv_Discharge_Steps#OPEN_OUTLET;
	                
	                // Open outlet valve
	            OutVlv_Discharge_Steps#OPEN_OUTLET:
	                #_stepTracker.next:= OutVlv_Discharge_Steps#DISCHARGING;
	                
	                // Discharge product
	            OutVlv_Discharge_Steps#DISCHARGING:
	                IF _.LIB.IsTimerExceeded(actualTimer:=#step.actualTimer, limit:=#parameters.dischargeTime) THEN
	                    #_stepTracker.next:= OutVlv_Discharge_Steps#CLOSE_OUTLET;
	                END_IF;
	                
	                // Close outlet valve
	            OutVlv_Discharge_Steps#CLOSE_OUTLET:
	                #_stepTracker.next := OutVlv_Discharge_Steps#DONE;
	                
	                // Discharge sequence complete
	            OutVlv_Discharge_Steps#DONE:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := OutVlv_Discharge_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned/Idle or Done and transition is enable
	        IF #enableStepTransition AND #cm_inPosition AND #mode_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset := NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	END_REGION
	
	REGION Actions
	    // NA
	    
	END_REGION
	
	REGION Control Modules: Commands 
	    
	    //********************************************************
	    // Start Open Outlet Mode Control
	    //********************************************************
	    #cmd_modeOpenOutlet := (#step.actual = OutVlv_Discharge_Steps#INITIAL) OR (#step.actual = OutVlv_Discharge_Steps#OPEN_OUTLET) OR (#step.actual = OutVlv_Discharge_Steps#DISCHARGING);
	    
	    //********************************************************
	    // Start Close Outlet Mode Control
	    //********************************************************
	    #cmd_modeCloseOutlet := (#step.actual = OutVlv_Discharge_Steps#CLOSE_OUTLET);
	    
	END_REGION
	
	
	REGION #feedbacks
	    // Update feedback statuses
	    #feedbacks.closingOutlet := (#step.actual = OutVlv_Discharge_Steps#CLOSE_OUTLET);
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when discharge complete
	    #status.done := NOT #status.idle AND #cm_inPosition AND (#step.actual = OutVlv_Discharge_Steps#DONE);
	                                    
	    // System busy during discharge sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_FlowThrough_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_interface_modesStatus
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      initialize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      discharge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      vent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      openHopper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      evacuate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      flowThrough { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      purge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      closeHopper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
      hold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_Evacuate_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
FUNCTION_BLOCK EM_OutVlv_holdPosition
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable step transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_HoldPosition_Params;   // Hold position parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate hold sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM/EM in position
      mode_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Mode idle or done
      outletVlv_isClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outlet valve is closed
   END_VAR

   VAR_OUTPUT 
      cmd_modeOpenOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command open outlet mode
      cmd_modeCloseOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command close outlet mode
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_HoldPosition_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_HoldPosition_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_HoldPosition_Steps;   // Next step
      END_STRUCT;
      _vlvClosedAtInitialStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_OutVlv_holdPosition Logic
	    // Description: 
	    // - Manages the hold position sequence for the outlet valve, maintaining the last valve position.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active
	            OutVlv_HoldPosition_Steps#INITIAL:
	                #_stepTracker.next := OutVlv_HoldPosition_Steps#HELD;
	                
	                // Hold outlet valve position
	            OutVlv_HoldPosition_Steps#HELD:
	                #_stepTracker.next := OutVlv_HoldPosition_Steps#DONE;
	                
	                // Hold position sequence complete
	            OutVlv_HoldPosition_Steps#DONE:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := OutVlv_HoldPosition_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned/Idle or Done and transition is enable
	        IF  #enableStepTransition AND #cm_inPosition AND #mode_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset := NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	    
	END_REGION
	
	REGION Actions
	    IF #step.actual = OutVlv_HoldPosition_Steps#INITIAL THEN
	        #_vlvClosedAtInitialStep := #outletVlv_isClosed;
	    END_IF;
	    
	END_REGION
	
	REGION Control Modules: Commands     
	    //********************************************************
	    // Open Outlet Mode Control
	    //********************************************************
	    REGION Open Outlet Mode
	        // Command Open outlet mode
	        #cmd_modeOpenOutlet := #activate AND (NOT #_vlvClosedAtInitialStep);
	        
	    END_REGION
	    
	    //********************************************************
	    // Close Outlet Mode Control
	    //********************************************************
	    REGION Close Outlet Mode
	        // Command Close outlet mode
	        #cmd_modeCloseOutlet := #activate AND  #_vlvClosedAtInitialStep;
	        
	    END_REGION
	    
	END_REGION
	
	REGION #feedbacks
	    // Update feedback statuses
	    #feedbacks.held := (#step.actual = OutVlv_HoldPosition_Steps#HELD) OR (#step.actual = OutVlv_HoldPosition_Steps#DONE);
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when position held
	    #status.done := NOT #status.idle AND #cm_inPosition AND (#step.actual = OutVlv_HoldPosition_Steps#DONE);
	                                    
	    // System busy during hold sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_OpenHopper_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_parameters_variable
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      transferLineEmptyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt := 2;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_CloseHopper_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_Vent_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      ventTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 5;   // Vent Time
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_Hold_Params
{ Published := 'TRUE' }
VERSION : 0.1
// This UDT is not published for external use
   STRUCT
      na { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_parameters_fixed
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      em_vac : _.EM_Vac.Vac_parameters_fixed;   // EM Vacuum: Fixed parameters
      em_outVlv : _.EM_OutVlv.OutVlv_parameters_fixed;   // EM Hopper: Fixed parameters
      ventTime { S7_SetPoint := 'True'} : USInt := 5;   // Vent time (de-pressure)
      dischargeTime { S7_SetPoint := 'True'} : USInt := 40;   // Discharge Time
      isolationVlvCloseDelay { S7_SetPoint := 'True'} : USInt := 5;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
FUNCTION_BLOCK EM_OutVlv_purge
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable step transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_Purge_Params;   // Purge parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate purge sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM/EM in position
      mode_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Mode idle or done
      outletVlv_isOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outlet valve is closed
   END_VAR

   VAR_OUTPUT 
      cmd_modeOpenOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command open outlet mode
      cmd_modeCloseOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command close outlet mode
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_Purge_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_Purge_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_Purge_Steps;   // Next step
      END_STRUCT;
      _actualPurgeCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_OutVlv_purge Logic
	    // Description: 
	    // - Manages the purge sequence for the outlet valve, cycling open and close to clear the hopper.
	    //********************************************************
	        
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	    
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active 
	            OutVlv_Purge_Steps#INITIAL:
	                #_stepTracker.next := OutVlv_Purge_Steps#START_DELAY;
	                
	                // Delay for purge start
	            OutVlv_Purge_Steps#START_DELAY:
	                IF _.LIB.IsTimerExceeded(actualTimer:=#step.actualTimer, limit:=#parameters.startDelay) THEN
	                    #_stepTracker.next := OutVlv_Purge_Steps#OPEN_OUTLET;
	                END_IF;
	                
	                // Open outlet valve
	            OutVlv_Purge_Steps#OPEN_OUTLET:
	                #_stepTracker.next := OutVlv_Purge_Steps#CLOSE_OUTLET;
	                
	                // Close the outlet valve
	            OutVlv_Purge_Steps#CLOSE_OUTLET:
	                #_stepTracker.next := OutVlv_Purge_Steps#CHECK_PURGE_COUNT;
	                
	                // Check purge cycle count
	            OutVlv_Purge_Steps#CHECK_PURGE_COUNT:
	                IF #_actualPurgeCount >= #parameters.count THEN
	                    #_stepTracker.next := OutVlv_Purge_Steps#DONE;
	                ELSE
	                    #_stepTracker.next := OutVlv_Purge_Steps#OPEN_OUTLET;
	                END_IF;
	                
	                // Purge sequence complete
	            OutVlv_Purge_Steps#DONE:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := OutVlv_Purge_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned/Idle or Done and transition is enable
	        IF #enableStepTransition AND #cm_inPosition AND #mode_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset := NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	    
	END_REGION
	
	REGION Actions
	    CASE #step.actual OF
	        OutVlv_Purge_Steps#RESET_STEP..OutVlv_Purge_Steps#INITIAL:
	            #_actualPurgeCount := 0;
	            
	        OutVlv_Purge_Steps#CHECK_PURGE_COUNT:
	            IF #step.firstCycle THEN
	                #_actualPurgeCount += 1;
	            END_IF;
	            
	        ELSE  
	            ;
	    END_CASE;
	    
	END_REGION
	
	REGION Control Modules: Commands     
	    //********************************************************
	    // Start Open Outlet Mode Control
	    //********************************************************
	    #cmd_modeOpenOutlet :=
	        (#step.actual = OutVlv_Purge_Steps#OPEN_OUTLET) OR
	        (((#step.actual = OutVlv_Purge_Steps#INITIAL) OR (#step.actual = OutVlv_Purge_Steps#START_DELAY)) AND #outletVlv_isOpen);
	        
	    
	    //********************************************************
	    // Start Close Outlet Mode Control
	    //********************************************************
	        #cmd_modeCloseOutlet := (#step.actual = OutVlv_Purge_Steps#CLOSE_OUTLET);
	    
	END_REGION
	
	REGION #feedbacks
	    // Update feedback statuses
	    #feedbacks.purging := (#step.actual >= OutVlv_Purge_Steps#INITIAL);
	    #feedbacks.waitingStartDelay := (#step.actual = OutVlv_Purge_Steps#START_DELAY);
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when purge complete
	    #status.done := NOT #status.idle AND #cm_inPosition AND (#step.actual = OutVlv_Purge_Steps#DONE) AND (NOT #step.firstCycle);
	                                    
	    // System busy if purge is not complete
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_interface
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      cmd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Vac_Cmd;
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_status;
      modesStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Vac_interface_modesStatus;
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Vac_interface_feedbacks;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_parameters
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      fixed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_parameters_fixed;
      variable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_parameters_variable;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
FUNCTION_BLOCK EM_Vac_initialize
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      en_stepTrans { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate/Stop sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM/EM in position
      mode_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Modes(ext): Idle or Done
   END_VAR

   VAR_OUTPUT 
      cmd_modeStartVacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to startVacuum mode
      cmd_modeStopVacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to stopVacuum mode
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Vac_Initialize_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Vac_Initialize_Steps;
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Vac_Initialize_Steps;
      END_STRUCT;
   END_VAR


BEGIN
	
	REGION Header
	    //********************************************************
	    // EM_Vac_initializeVacuum Logic
	    // Description: 
	    // - Manages the initialization sequence for the vacuum system, checking start and stop modes.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	            Author      Date        Change
	            GEA-VAR     15MAY25     Initial version
	        *)
	    END_REGION
	    
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active   
	            Vac_Initialize_Steps#INITIAL:
	                #_stepTracker.next := Vac_Initialize_Steps#START_VACUUM;
	                
	                // Start vacuum mode   
	            Vac_Initialize_Steps#START_VACUUM:
	                #_stepTracker.next := Vac_Initialize_Steps#STOP_VACUUM;
	                
	                // Stop vacuum mode
	            Vac_Initialize_Steps#STOP_VACUUM:
	                #_stepTracker.next := Vac_Initialize_Steps#INITIALIZED;
	                
	                //  Initialization complete
	            Vac_Initialize_Steps#INITIALIZED:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := Vac_Initialize_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned/Idle or Done and transition is enable
	        IF #en_stepTrans AND #cm_inPosition AND #mode_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset:=NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	END_REGION
	
	REGION Actions
	    // NA
	    
	END_REGION
	
	REGION Control/Equipment Modules and Modes: Commands 
	    
	    //********************************************************
	    // Start Vacuum Mode Control
	    //********************************************************
	    #cmd_modeStartVacuum := (#step.actual = Vac_Initialize_Steps#START_VACUUM);
	    
	    
	    //********************************************************
	    // Vacuum Valve Control
	    //********************************************************
	    #cmd_modeStopVacuum := (#step.actual = Vac_Initialize_Steps#STOP_VACUUM);
	    
	    
	END_REGION
	
	
	REGION #feedbacks
	    #feedbacks.initialized := #cm_inPosition AND #mode_idleOrDone AND (#step.actual = Vac_Initialize_Steps#INITIALIZED);
	    
	END_REGION
	
	
	REGION Status
	    // Idle when sequence not active
	    #status.idle := NOT #activate;
	                                    
	    // Done when initialized
	    #status.done := NOT #status.idle AND #feedbacks.initialized;
	                                    
	    // Busy during initialization
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_Vac
FUNCTION_BLOCK EM_Vac_startVacuum
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Vac_StartVacuum_Params;   // Start vacuum parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate/Stop sequence
      emptyLine { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM/EM in position
      AHU_minAirflowReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // AHU minimum airflow reached
      vacuumAirflow_PV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Vacuum airflow process value
   END_VAR

   VAR_OUTPUT 
      cmd_isolationVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to open isolation valve
      cmd_vacuumVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to open vacuum valve
      setpoint_vacuumControlVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Vacuum control valve setpoint
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Vac_StartVacuum_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Vac_StartVacuum_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Vac_StartVacuum_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_Vac_startVacuum Logic
	    // Description: 
	    // - Manages the start sequence for the vacuum system, ensuring proper airflow and valve operation..
	    //********************************************************
	    
	    REGION Revision History
	        (*
	            Author      Date        Change
	            GEA-VAR     15MAY25     Initial version
	        *)
	    END_REGION
	    
	END_REGION
	
	//********************************************************
	// Region: Start Vacuum Mode
	// Description: Handles the startup sequence for the vacuum system, 
	// ensuring proper airflow, valve operation, and pump activation.
	//********************************************************
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active 
	            Vac_StartVacuum_Steps#INITIAL:
	                #_stepTracker.next := Vac_StartVacuum_Steps#CHECK_AHU_MIN_AIRFLOW;
	                
	                // Verify AHU minimum airflow   
	            Vac_StartVacuum_Steps#CHECK_AHU_MIN_AIRFLOW:
	                IF #AHU_minAirflowReached THEN
	                    #_stepTracker.next := Vac_StartVacuum_Steps#START_VACUUM_PUMP;
	                END_IF;
	                
	                // Start vacuum pump
	            Vac_StartVacuum_Steps#START_VACUUM_PUMP:
	                #_stepTracker.next := Vac_StartVacuum_Steps#BUILD_UP_VACUUM;
	                
	                // Build vacuum pressure
	            Vac_StartVacuum_Steps#BUILD_UP_VACUUM:
	                IF _.LIB.IsTimerExceeded(actualTimer := #step.actualTimer, limit := #parameters.vacuumBuildUpTimer) THEN
	                    #_stepTracker.next := Vac_StartVacuum_Steps#OPEN_ISOLATION_VALVE;
	                END_IF;
	                
	                // Open isolation valve
	            Vac_StartVacuum_Steps#OPEN_ISOLATION_VALVE:
	                #_stepTracker.next := Vac_StartVacuum_Steps#CHECK_MIN_VACUUM_AIRFLOW;
	                
	                // Verify minimum vacuum airflow
	            Vac_StartVacuum_Steps#CHECK_MIN_VACUUM_AIRFLOW:
	                IF (#vacuumAirflow_PV >= #parameters.minVacuumAirFlow) THEN
	                    #_stepTracker.next := Vac_StartVacuum_Steps#VACUUM_OPERATION_READY;
	                END_IF;
	                
	                // Vacuum ready for operation
	            Vac_StartVacuum_Steps#VACUUM_OPERATION_READY:
	                IF (#vacuumAirflow_PV < #parameters.minVacuumAirFlow) THEN
	                    #_stepTracker.next := Vac_StartVacuum_Steps#CHECK_MIN_VACUUM_AIRFLOW;
	                ELSIF #emptyLine THEN
	                    #_stepTracker.next := Vac_StartVacuum_Steps#EMPTY_LINE;
	                    
	                END_IF;
	                
	                // Empty Line
	            Vac_StartVacuum_Steps#EMPTY_LINE:
	                IF (#vacuumAirflow_PV < #parameters.minVacuumAirFlow) THEN
	                    #_stepTracker.next := Vac_StartVacuum_Steps#CHECK_MIN_VACUUM_AIRFLOW;
	                END_IF;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := Vac_StartVacuum_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned/Idle or Done and transition is enable
	        IF #enableStepTransition AND #cm_inPosition THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset:=NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	    
	END_REGION
	
	REGION Actions
	    // NA
	    
	END_REGION
	
	REGION Control Modules: Commands     
	    //********************************************************
	    // Isolation Valve Control
	    //********************************************************
	    REGION Isolation Valve
	        // Command to open
	        #cmd_isolationVlvOpen :=
	            (#step.actual = Vac_StartVacuum_Steps#OPEN_ISOLATION_VALVE) OR
	            (#step.actual = Vac_StartVacuum_Steps#CHECK_MIN_VACUUM_AIRFLOW) OR
	            (#step.actual = Vac_StartVacuum_Steps#VACUUM_OPERATION_READY) OR
	            (#step.actual = Vac_StartVacuum_Steps#EMPTY_LINE);
	        
	    END_REGION
	    
	    //********************************************************
	    // Vacuum Valve Control
	    //********************************************************
	    REGION Vacuum Valve
	        // Command to open
	        #cmd_vacuumVlvOpen :=
	            (#step.actual = Vac_StartVacuum_Steps#START_VACUUM_PUMP) OR
	            (#step.actual = Vac_StartVacuum_Steps#BUILD_UP_VACUUM) OR
	            (#step.actual = Vac_StartVacuum_Steps#OPEN_ISOLATION_VALVE) OR
	            (#step.actual = Vac_StartVacuum_Steps#CHECK_MIN_VACUUM_AIRFLOW) OR
	            (#step.actual = Vac_StartVacuum_Steps#VACUUM_OPERATION_READY) OR
	            (#step.actual = Vac_StartVacuum_Steps#EMPTY_LINE);
	        
	    END_REGION
	    
	    //********************************************************
	    // Vacuum Control Valve
	    //********************************************************
	    REGION Vacuum Control Valve
	        // Set vacuum control setpoint depending on state
	        IF #cmd_vacuumVlvOpen THEN
	            #setpoint_vacuumControlVlv := #parameters.vacuumControlSP;
	        ELSE
	            #setpoint_vacuumControlVlv := #parameters.vacuumControlMinOpening;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	
	REGION Feedbacks
	    // Update feedback statuses
	    #feedbacks.waitingAhuMinAirflow := (#step.actual = Vac_StartVacuum_Steps#CHECK_AHU_MIN_AIRFLOW);
	    
	    #feedbacks.buildingUpVacuum := (#step.actual = Vac_StartVacuum_Steps#BUILD_UP_VACUUM);
	    
	    #feedbacks.vacuumOperationReady := (#vacuumAirflow_PV >= #parameters.minVacuumAirFlow);
	    
	    #feedbacks.startingVacuum := (#step.actual >= Vac_StartVacuum_Steps#INITIAL) AND  (NOT #feedbacks.vacuumOperationReady);
	    
	    #feedbacks.minAirflowReached := #vacuumAirflow_PV >= #parameters.minVacuumAirFlow;
	    
	    #feedbacks.minTimeLineEmptyReached := (#step.actual = Vac_StartVacuum_Steps#EMPTY_LINE) AND _.LIB.IsTimerExceeded(actualTimer := #step.actualTimer, limit := #parameters.minTimeLineEmpty);
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when vacuum is stopped
	    #status.done := NOT #status.idle AND #cm_inPosition AND (#step.actual = Vac_StartVacuum_Steps#VACUUM_OPERATION_READY);
	                                    
	    // System busy during stop sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_interface_feedbacks
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      transferLineEmpty { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transfer lines is empty
      modes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Modes feedbacks
         initialize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Initialize_Feedbacks;
         discharge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Discharge_Feedbacks;
         vent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Vent_Feedbacks;
         openHopper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_OpenHopper_Feedbacks;
         evacuate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Evacuate_Feedbacks;
         flowThrough { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_FlowThrough_Feedbacks;
         purge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Purge_Feedbacks;
         closeHopper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_CloseHopper_Feedbacks;
         hold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Hold_Feedbacks;
      END_STRUCT;
      em_vacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.EM_Vac.Vac_interface_feedbacks;
      em_hopper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.EM_OutVlv.OutVlv_interface_feedbacks;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_Vac
FUNCTION_BLOCK EM_Vac_stopVacuum
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Vac_StopVacuum_Params;   // Stop vacuum parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate/Stop sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM/EM in position
      vacuumVlv_isOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vacuum valve open
      vacuumVlv_isClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Vacuum valve closed
      isolationVlv_isOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Isolation valve open
      isolationVlv_isClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Isolation valve closed
   END_VAR

   VAR_OUTPUT 
      cmd_isolationVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to open isolation valve
      cmd_vacuumVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to open vacuum valve
      setpoint_vacuumControlVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Vacuum control valve setpoint
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Vac_StopVacuum_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Vac_StopVacuum_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Vac_StopVacuum_Steps;   // Next step
      END_STRUCT;
   END_VAR

   VAR CONSTANT 
      DEFAULT_VACUUM_CONTROL_MAX_OPENING : USInt := 100;
      DEFAULT_VACUUM_CONTROL_MIN_OPENING : USInt;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_Vac_stopVacuum Logic
	    // Description: 
	    // - Manages the stop sequence for the vacuum system, controlling valves and pump.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	            Author      Date        Change
	            GEA-VAR     15MAY25     Initial version
	        *)
	    END_REGION
	    
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, sequence inactive   
	            Vac_StopVacuum_Steps#INITIAL:
	                #_stepTracker.next := Vac_StopVacuum_Steps#ISOLATION_VALVE_CLOSE_DELAY_ACTIVE;
	                
	                // Wait for isolation valve close delay
	            Vac_StopVacuum_Steps#ISOLATION_VALVE_CLOSE_DELAY_ACTIVE:
	                IF _.LIB.IsTimerExceeded(actualTimer:=#step.actualTimer, limit:=#parameters.isolationVlvCloseDelay) OR #isolationVlv_isClosed THEN
	                    #_stepTracker.next := Vac_StopVacuum_Steps#CLOSE_ISOLATION_VALVE;
	                END_IF;
	                
	                //  Command isolation valve to close
	            Vac_StopVacuum_Steps#CLOSE_ISOLATION_VALVE:
	                #_stepTracker.next := Vac_StopVacuum_Steps#STOP_VACUUM_PUMP_DELAY_ACTIVE;
	                
	                // Wait for vacuum pump valve close delay
	            Vac_StopVacuum_Steps#STOP_VACUUM_PUMP_DELAY_ACTIVE:
	                IF _.LIB.IsTimerExceeded(actualTimer:=#step.actualTimer, limit:=#parameters.vacuumVlvCloseDelay) OR #vacuumVlv_isClosed THEN
	                    #_stepTracker.next := Vac_StopVacuum_Steps#STOP_VACUUM_PUMP;
	                END_IF;
	                
	                // Command vacuum pump valve to close
	            Vac_StopVacuum_Steps#STOP_VACUUM_PUMP:
	                #_stepTracker.next := Vac_StopVacuum_Steps#VACUUM_STOPPED;
	                
	                // Vacuum pump stopped, sequence complete
	            Vac_StopVacuum_Steps#VACUUM_STOPPED:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := Vac_StopVacuum_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned/Idle or Done and transition is enable
	        IF #enableStepTransition AND #cm_inPosition THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset:=NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	    
	END_REGION
	
	REGION Actions
	    // NA
	    
	END_REGION
	
	REGION Control Modules: Commands     
	    //********************************************************
	    // Isolation Valve Control
	    //********************************************************
	    REGION Isolation Valve
	        // Set open command for valve
	        #cmd_isolationVlvOpen :=
	            #isolationVlv_isOpen AND 
	            ((#step.actual = Vac_StopVacuum_Steps#INITIAL) OR
	            (#step.actual = Vac_StopVacuum_Steps#ISOLATION_VALVE_CLOSE_DELAY_ACTIVE));
	        
	    END_REGION
	    
	    //********************************************************
	    // Vacuum Valve Control
	    //********************************************************
	    REGION Vacuum Valve
	        // Command to open
	        #cmd_vacuumVlvOpen :=
	            #vacuumVlv_isOpen AND
	            ((#step.actual = Vac_StopVacuum_Steps#INITIAL) OR
	            (#step.actual = Vac_StopVacuum_Steps#ISOLATION_VALVE_CLOSE_DELAY_ACTIVE) OR
	            (#step.actual = Vac_StopVacuum_Steps#CLOSE_ISOLATION_VALVE) OR
	            (#step.actual = Vac_StopVacuum_Steps#STOP_VACUUM_PUMP_DELAY_ACTIVE));
	        
	    END_REGION
	    
	    //********************************************************
	    // Vacuum Control Valve
	    //********************************************************
	    REGION Vacuum Control Valve
	        // Set vacuum control valve setpoint
	        IF #cmd_vacuumVlvOpen THEN
	            #setpoint_vacuumControlVlv := #parameters.vacuumControlSP;
	        ELSE
	            #setpoint_vacuumControlVlv := #DEFAULT_VACUUM_CONTROL_MIN_OPENING;
	        END_IF;
	        
	        #setpoint_vacuumControlVlv := LIMIT_USINT(MN := #parameters.vacuumControlMinOpening, IN := #setpoint_vacuumControlVlv, MX := #DEFAULT_VACUUM_CONTROL_MAX_OPENING);
	        
	    END_REGION
	    
	END_REGION
	
	REGION #feedbacks
	    // Update feedback statuses
	    #feedbacks.waitingIsolationVlvCloseDelay := (#step.actual = Vac_StopVacuum_Steps#ISOLATION_VALVE_CLOSE_DELAY_ACTIVE);
	    
	    #feedbacks.waitingVacuumVlvCloseDelay := (#step.actual = Vac_StopVacuum_Steps#STOP_VACUUM_PUMP_DELAY_ACTIVE);
	        
	    #feedbacks.vacuumStopped := (#step.actual = Vac_StopVacuum_Steps#VACUUM_STOPPED);
	    
	    #feedbacks.stoppingVacuum := (#step.actual >= _.EM_Vac.Vac_StopVacuum_Steps#INITIAL) AND (NOT #feedbacks.vacuumStopped);
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when vacuum is stopped
	    #status.done := NOT #status.idle AND #cm_inPosition AND (#step.actual = Vac_StopVacuum_Steps#VACUUM_STOPPED);
	                                    
	    // System busy during stop sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM
DATA_BLOCK TODO
{ DB_Accessible_From_OPC_UA := 'FALSE' ;
 S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      alm { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      "bool" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      isolationVlv_isOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      isolationVlv_isClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      vacuumVlv_isOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      vacuumVlv_isClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      vacuumControlVlv_cmdOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      setpoint_vacuumControlVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
      isolationVlv_cmdOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      vacuumVlv_cmdOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      vacHop_inputs : _.EM_VacHop.VacHop_inputs;
   END_VAR


BEGIN
   vacHop_inputs.em_vac_inputs.AHU_minAirflowReached := true;

END_DATA_BLOCK
END_NAMESPACE

NAMESPACE EM_Vac
TYPE Vac_parameters
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      fixed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Vac_parameters_fixed;
      variable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Vac_parameters_variable;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
TYPE OutVlv_interface
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      cmd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_Cmd;
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_status;
      modesStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_interface_modesStatus;
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_interface_feedbacks;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_OutVlv
FUNCTION_BLOCK EM_OutVlv_closeOutlet
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_CloseOutlet_Params;   // Close outlet parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate mode
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM in position
      outletVlv_isOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outlet valve is open
      outletVlv_isClosed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outlet valve is closed
   END_VAR

   VAR_OUTPUT 
      cmd_outletVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command: outlet valve Open
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_CloseOutlet_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_CloseOutlet_Steps;
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_CloseOutlet_Steps;
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_OutVlv_closeOutlet Logic
	    // Description: 
	    // - Manages the hopper outlet closing sequence, ensuring proper valve closure timing.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	    
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active
	            OutVlv_CloseOutlet_Steps#INITIAL:
	                #_stepTracker.next := OutVlv_CloseOutlet_Steps#CLOSE_VLV_DELAY_ACTIVE;
	                
	                // Delay for outlet valve closure  
	            OutVlv_CloseOutlet_Steps#CLOSE_VLV_DELAY_ACTIVE:
	                IF (_.LIB.IsTimerExceeded(actualTimer := #step.actualTimer, limit := #parameters.vlvCloseDelay)) OR  #outletVlv_isClosed THEN
	                    #_stepTracker.next := OutVlv_CloseOutlet_Steps#CLOSE_VLV;
	                END_IF;
	                
	                // Close outlet valve
	            OutVlv_CloseOutlet_Steps#CLOSE_VLV:
	                #_stepTracker.next := OutVlv_CloseOutlet_Steps#OUTLET_CLOSED;
	                
	                // Outlet valve closed, sequence complete
	            OutVlv_CloseOutlet_Steps#OUTLET_CLOSED:
	                ;
	                
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := OutVlv_CloseOutlet_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned/Idle or Done and transition is enable
	        IF #enableStepTransition AND #cm_inPosition THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset:=NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	    
	END_REGION
	
	REGION Actions
	    // NA
	    
	END_REGION
	
	REGION Control Modules: Commands     
	    //********************************************************
	    // Outlet Valve Control
	    //********************************************************
	    REGION Outlet Valve
	        // Command to open
	        #cmd_outletVlvOpen := #outletVlv_isOpen AND
	        ((#step.actual = OutVlv_CloseOutlet_Steps#INITIAL) OR
	        (#step.actual = OutVlv_CloseOutlet_Steps#CLOSE_VLV_DELAY_ACTIVE));
	        
	    END_REGION
	    
	END_REGION
	
	
	REGION Feedbacks
	    // Update feedback statuses
	    #feedbacks.waitingOutletCloseDelay := (#step.actual = OutVlv_CloseOutlet_Steps#CLOSE_VLV_DELAY_ACTIVE);
	    #feedbacks.outletClosed := #outletVlv_isClosed;
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := (NOT #activate);
	                                    
	    // System done when outlet valve is closed
	    #status.done := (NOT #status.idle) AND #cm_inPosition AND (#step.actual = OutVlv_CloseOutlet_Steps#OUTLET_CLOSED);
	                                    
	    // System busy during closeOutlet Sequence
	    #status.busy := NOT (#status.idle OR #status.done);
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_OutVlv
FUNCTION_BLOCK EM_OutVlv_openOutlet
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable step transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_OpenOutlet_Params;   // Open outlet parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate open sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM/EM in position
      outletVlv_isOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outlet valve is open
   END_VAR

   VAR_OUTPUT 
      cmd_outletVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command: outlet valve open
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_OpenOutlet_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_OpenOutlet_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_OpenOutlet_Steps;   // Next step
      END_STRUCT;
      _vlvOpenAtInitialStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_OutVlv_openOutlet Logic
	    // Description: 
	    // - Manages the outlet valve opening sequence, ensuring proper valve opening timing.
	    //********************************************************
	        
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	    
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active  
	            OutVlv_OpenOutlet_Steps#INITIAL:
	                #_stepTracker.next := OutVlv_OpenOutlet_Steps#OPEN_VLV_DELAY_ACTIVE;
	                
	                // Delay for outlet valve opening  
	            OutVlv_OpenOutlet_Steps#OPEN_VLV_DELAY_ACTIVE:
	                IF _.LIB.IsTimerExceeded(actualTimer:=#step.actualTimer, limit:=#parameters.vlvOpenDelay) OR #_vlvOpenAtInitialStep THEN
	                    #_stepTracker.next := OutVlv_OpenOutlet_Steps#OPEN_VLV;
	                END_IF;
	                
	                // Open outlet valve
	            OutVlv_OpenOutlet_Steps#OPEN_VLV:
	                #_stepTracker.next := OutVlv_OpenOutlet_Steps#OUTLET_OPENED;
	                
	                // Outlet valve is open
	            OutVlv_OpenOutlet_Steps#OUTLET_OPENED:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := OutVlv_OpenOutlet_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned/Idle or Done and transition is enable
	        IF #enableStepTransition AND #cm_inPosition THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset:=NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	END_REGION
	
	REGION Actions
	    IF #step.actual = OutVlv_OpenOutlet_Steps#INITIAL THEN
	        #_vlvOpenAtInitialStep := #outletVlv_isOpen;
	    END_IF;
	    
	END_REGION
	
	REGION Control Modules: Commands 
	    
	    //********************************************************
	    // Outlet Valve Control
	    //********************************************************
	    REGION Outlet Valve
	        // Command to open
	        #cmd_outletVlvOpen := (#_vlvOpenAtInitialStep AND
	            ((#step.actual = OutVlv_OpenOutlet_Steps#INITIAL) OR
	            (#step.actual = OutVlv_OpenOutlet_Steps#OPEN_VLV_DELAY_ACTIVE)))
	            OR
	            (#step.actual = OutVlv_OpenOutlet_Steps#OPEN_VLV) OR
	            (#step.actual = OutVlv_OpenOutlet_Steps#OUTLET_OPENED);
	        
	    END_REGION
	    
	END_REGION
	
	
	REGION Feedbacks
	    // Update feedback statuses
	    #feedbacks.waitingOutletOpenDelay := (NOT #_vlvOpenAtInitialStep) AND (#step.actual = OutVlv_OpenOutlet_Steps#OPEN_VLV_DELAY_ACTIVE);
	    #feedbacks.outletOpened := (#step.actual = OutVlv_OpenOutlet_Steps#OUTLET_OPENED);
	    
	END_REGION
	
	REGION Status
	    // The system is idle when inactive
	    #status.idle := NOT #activate;
	                                    
	    // The system is "done" when outlet valve is open
	    #status.done := NOT #status.idle AND #cm_inPosition AND (#step.actual = OutVlv_OpenOutlet_Steps#OUTLET_OPENED);
	                                    
	    // The system is busy when it's active but not yet completed
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_OutVlv
FUNCTION_BLOCK EM_OutVlv_initialize
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable step transition
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate initialize sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM/EM in position
      mode_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Mode idle or done
   END_VAR

   VAR_OUTPUT 
      cmd_modeOpenOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command open outlet mode
      cmd_modeCloseOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command close outlet mode
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_Initialize_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_Initialize_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_Initialize_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_OutVlv_initialize Logic
	    // Description: 
	    // - Executes the initialization sequence for the outlet valve.
	    // - Ensures the system resets all relevant internal states and flags.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active    
	            OutVlv_Initialize_Steps#INITIAL:
	                #_stepTracker.next := OutVlv_Initialize_Steps#OPEN_OUTLET;
	                
	                // Open outlet valve
	            OutVlv_Initialize_Steps#OPEN_OUTLET:
	                #_stepTracker.next := OutVlv_Initialize_Steps#CLOSE_OUTLET;
	                
	                // Close outlet valve
	            OutVlv_Initialize_Steps#CLOSE_OUTLET :
	                #_stepTracker.next := OutVlv_Initialize_Steps#INITIALIZED;
	                
	                //  Initialized
	            OutVlv_Initialize_Steps#INITIALIZED:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := OutVlv_Initialize_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned/Idle or Done and transition is enable
	        IF #enableStepTransition AND #cm_inPosition AND #mode_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset:=NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	    
	END_REGION
	
	REGION Actions
	    // NA
	    
	END_REGION
	
	REGION Control/Equipment Modules and Modes: Commands     
	    //********************************************************
	    //  Start Open Outlet Mode Control
	    //********************************************************
	    #cmd_modeOpenOutlet := (#step.actual = OutVlv_Initialize_Steps#OPEN_OUTLET);
	    
	    
	    //********************************************************
	    //  Start Close Outlet Mode Control
	    //********************************************************
	    #cmd_modeCloseOutlet := (#step.actual = OutVlv_Initialize_Steps#CLOSE_OUTLET);
	    
	    
	    
	END_REGION
	
	REGION #feedbacks
	    // Update feedback statuses
	    #feedbacks.initialized :=  #cm_inPosition AND #mode_idleOrDone AND (#step.actual = OutVlv_Initialize_Steps#INITIALIZED) AND (NOT #step.firstCycle);
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when initialized step is reached
	    #status.done := NOT #status.idle AND  #feedbacks.initialized;
	                                    
	    // System busy if initialize is not complete
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_parameters
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      fixed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_parameters_fixed;
      variable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_parameters_variable;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
FUNCTION_BLOCK EM_VacHop_flowThrough
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_FlowThrough_Params;
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM in position
      em_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Idle or Done
      em_vacuum_startVacuum_idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Vacuum: Start Vacuum mode idle
      em_outVlv_outletClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM_OutVlv: outlet valve is open
   END_VAR

   VAR_OUTPUT 
      cmd_em_vacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_Vac.Vac_Cmd;   // EM_Vacuum: Command
      cmd_em_outVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_OutVlv.OutVlv_Cmd;   // EM_OutVlv: Command
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_FlowThrough_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_FlowThrough_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_FlowThrough_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_VacHop_flowThrough Logic
	    // Description: 
	    // - Manages the flowthrough sequence for the vacuum hopper, starting vacuum and opening the outlet valve.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active  
	            VacHop_FlowThrough_Steps#INITIAL:
	                #_stepTracker.next := VacHop_FlowThrough_Steps#CREATE_VACUUM;
	                
	                // Start vacuum system  
	            VacHop_FlowThrough_Steps#CREATE_VACUUM:
	                #_stepTracker.next := VacHop_FlowThrough_Steps#OPEN_OUTLET;
	                
	                //  Open outlet valve
	            VacHop_FlowThrough_Steps#OPEN_OUTLET:
	                #_stepTracker.next := VacHop_FlowThrough_Steps#READY;
	                
	                //  Flowthrough ready
	            VacHop_FlowThrough_Steps#READY:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := VacHop_FlowThrough_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned
	        IF #enableStepTransition AND #cm_inPosition AND #em_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset := NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	END_REGION
	
	REGION Equipment Modules   
	    REGION Vacuum: Commands        
	        CASE #step.actual OF
	            VacHop_FlowThrough_Steps#RESET_STEP:
	                // Set vacuum to idle
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	                
	            VacHop_FlowThrough_Steps#INITIAL:
	                // Start vacuum or wait for idle
	                IF #em_vacuum_startVacuum_idle THEN
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	                ELSE
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#START_VACUUM;
	                END_IF;
	            ELSE
	                // Maintain vacuum active
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#START_VACUUM;
	        END_CASE;
	        
	    END_REGION
	    
	    REGION Outlet Valve: Command     
	        CASE #step.actual OF
	            VacHop_FlowThrough_Steps#RESET_STEP:
	                // Set outlet valve to idle
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                
	            VacHop_FlowThrough_Steps#INITIAL..VacHop_FlowThrough_Steps#CREATE_VACUUM:
	                // Open outlet valve or wait for close
	                IF NOT #em_outVlv_outletClose THEN
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#OPEN_OUTLET;
	                    
	                END_IF;
	            ELSE
	                // Maintain outlet valve open
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#OPEN_OUTLET;
	                
	        END_CASE;
	        
	    END_REGION
	    
	END_REGION
	
	REGION Control Modules: Commands 
	    //********************************************************
	    // NA
	    //********************************************************
	    
	END_REGION
	
	REGION Feedbacks
	    // na
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when flowthrough complete
	    #status.done := NOT #status.idle AND #cm_inPosition AND #em_idleOrDone AND (#step.actual = VacHop_FlowThrough_Steps#READY);
	                                    
	    //System busy during flowthrough sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
TYPE VacHop_interface
{ Published := 'TRUE' }
VERSION : 0.1
   STRUCT
      cmd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Cmd;
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_status;
      modesStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_interface_modesStatus;
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_interface_feedbacks;
   END_STRUCT;

END_TYPE
END_NAMESPACE

NAMESPACE EM_VacHop
FUNCTION_BLOCK EM_VacHop_evacuate
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Evacuate_Params;
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM in position
      em_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Idle or Done
      em_vacuum_startVacuum_idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Vacuum: Start Vacuum mode idle
      em_outVlv_outletClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM_OutVlv: outlet valve is open
   END_VAR

   VAR_OUTPUT 
      cmd_em_vacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_Vac.Vac_Cmd;   // EM_Vacuum: Command
      cmd_em_outVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_OutVlv.OutVlv_Cmd;   // EM_OutVlv: Command
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Evacuate_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Evacuate_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Evacuate_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_VacHop_evacuate Logic
	    // Description: 
	    // - Manages the evacuation sequence for the vacuum hopper, closing the outlet and starting the vacuum system.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active   
	            VacHop_Evacuate_Steps#INITIAL:
	                #_stepTracker.next := VacHop_Evacuate_Steps#CLOSE_OUTLET;
	                
	                // Close outlet valve    
	            VacHop_Evacuate_Steps#CLOSE_OUTLET:
	                #_stepTracker.next := VacHop_Evacuate_Steps#CREATE_VACUUM;
	                
	                //  Start vacuum system
	            VacHop_Evacuate_Steps#CREATE_VACUUM:
	                #_stepTracker.next := VacHop_Evacuate_Steps#DONE;
	                
	                //  Evacuation sequence complete
	            VacHop_Evacuate_Steps#DONE:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := VacHop_Evacuate_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned
	        IF #enableStepTransition AND #cm_inPosition AND #em_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset := NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	    
	END_REGION
	
	REGION Equipment Modules   
	    REGION Vacuum: Commands   
	        CASE #step.actual OF
	            VacHop_Evacuate_Steps#RESET_STEP:
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	                
	            VacHop_Evacuate_Steps#INITIAL..VacHop_Evacuate_Steps#CLOSE_OUTLET:
	                IF #em_vacuum_startVacuum_idle THEN
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	                ELSE
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#START_VACUUM;
	                END_IF;
	            ELSE
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#START_VACUUM;
	        END_CASE;
	        
	    END_REGION
	    
	    REGION Outlet Valve: Command     
	        CASE #step.actual OF
	            VacHop_Evacuate_Steps#INITIAL..VacHop_Evacuate_Steps#CLOSE_OUTLET:
	                IF NOT #em_outVlv_outletClose THEN
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#CLOSE_OUTLET;
	                ELSE
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                END_IF;
	            ELSE
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                
	        END_CASE;
	        
	    END_REGION
	    
	END_REGION
	
	REGION Control Modules: Commands 
	    //********************************************************
	    // NA
	    //********************************************************
	    
	END_REGION
	
	REGION Feedbacks
	    // NA
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when evacuation complete
	    #status.done := NOT #status.idle AND #cm_inPosition AND #em_idleOrDone AND (#step.actual = VacHop_Evacuate_Steps#DONE);
	                                    
	    // System busy during evacuation sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
FUNCTION_BLOCK EM_VacHop_openHopper
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_OpenHopper_Params;   // Open hopper parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate open sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM in position
      em_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Idle or Done
      em_vacuum_idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Vacuum:  idle
      em_outVlv_outletClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM_OutVlv outlet valve closed
   END_VAR

   VAR_OUTPUT 
      cmd_em_vacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_Vac.Vac_Cmd;   // EM_Vacuum: Command
      cmd_em_outVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_OutVlv.OutVlv_Cmd;   // EM_Hopper: Command
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_OpenHopper_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_OpenHopper_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_OpenHopper_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_VacHop_openHopper Logic
	    // Description: 
	    // - Manages the hopper outlet opening sequence for the vacuum hopper, stopping vacuum and opening the outlet valve.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active
	            VacHop_OpenHopper_Steps#INITIAL:
	                #_stepTracker.next := VacHop_OpenHopper_Steps#STOP_VACUUM;
	                
	                // Stop vacuum system
	            VacHop_OpenHopper_Steps#STOP_VACUUM:
	                #_stepTracker.next := VacHop_OpenHopper_Steps#OPEN_OUTLET;
	                
	                //  Open outlet valve
	            VacHop_OpenHopper_Steps#OPEN_OUTLET:
	                #_stepTracker.next := VacHop_OpenHopper_Steps#DONE;
	                
	                //  Outlet valve opened, sequence complete
	            VacHop_OpenHopper_Steps#DONE:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := VacHop_OpenHopper_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned
	        IF #enableStepTransition AND #cm_inPosition AND #em_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset := NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	    
	END_REGION
	
	REGION Control/Equipment Modules and Modes: Commands 
	    
	    REGION Vacuum: Commands        
	        CASE #step.actual OF
	            VacHop_OpenHopper_Steps#INITIAL..VacHop_OpenHopper_Steps#STOP_VACUUM:
	                IF #em_vacuum_idle THEN
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	                ELSE
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#STOP_VACUUM;
	                END_IF;
	            ELSE
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	        END_CASE;
	        
	    END_REGION
	    
	    REGION Outlet Valve: Command
	        CASE #step.actual OF
	            VacHop_OpenHopper_Steps#RESET_STEP:
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                
	            VacHop_OpenHopper_Steps#INITIAL..VacHop_OpenHopper_Steps#STOP_VACUUM:
	                IF NOT #em_outVlv_outletClose THEN
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#OPEN_OUTLET;
	                ELSE
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                END_IF;
	            ELSE
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#OPEN_OUTLET;
	        END_CASE;
	        
	    END_REGION
	    
	END_REGION
	
	REGION Control Modules: Commands 
	    //********************************************************
	    // NA
	    //********************************************************
	    
	END_REGION
	
	REGION Feedbacks
	    // NA
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when hopper opened
	    #status.done := (NOT #status.idle) AND #cm_inPosition AND #em_idleOrDone AND (#step.actual = VacHop_OpenHopper_Steps#DONE);
	                                    
	    // System busy during open sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
FUNCTION_BLOCK EM_VacHop_vent
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Vent_Params;   // Vent parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate vent sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM in position
      em_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Idle or Done
      em_vacuum_idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Vacuum:  idle
      em_outVlv_outletClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM_outVlv: outlet valve is closed
   END_VAR

   VAR_OUTPUT 
      cmd_em_vacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_Vac.Vac_Cmd;   // EM_Vacuum: Command
      cmd_em_outVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_OutVlv.OutVlv_Cmd;   // EM_outVlv: Command
      cmd_ventVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command vent valve open
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Vent_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Vent_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Vent_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_VacHop_vent Logic
	    // Description: 
	    // - Manages the vent sequence for the vacuum hopper, stopping vacuum, closing outlet, and cycling the vent valve.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active   
	            VacHop_Vent_Steps#INITIAL:
	                #_stepTracker.next := VacHop_Vent_Steps#STOP_VACUUM_AND_CLOSE_OUTLET;
	                
	                // Stop vacuum and close outlet valve
	            VacHop_Vent_Steps#STOP_VACUUM_AND_CLOSE_OUTLET:
	                #_stepTracker.next := VacHop_Vent_Steps#OPEN_VENT_VALVE;
	                
	                //  Open vent valve
	            VacHop_Vent_Steps#OPEN_VENT_VALVE:
	                #_stepTracker.next := VacHop_Vent_Steps#VENT_DELAY_ACTIVE;
	                
	                //  Delay for venting
	            VacHop_Vent_Steps#VENT_DELAY_ACTIVE:
	                IF _.LIB.IsTimerExceeded(actualTimer:=#step.actualTimer, limit:=#parameters.ventTime) THEN
	                    #_stepTracker.next := VacHop_Vent_Steps#CLOSE_VENT_VALVE;
	                END_IF;
	                
	                // Close vent valve
	            VacHop_Vent_Steps#CLOSE_VENT_VALVE:
	                #_stepTracker.next := VacHop_Vent_Steps#DONE;
	                
	                // Vent sequence complete
	            VacHop_Vent_Steps#DONE:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := VacHop_Vent_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned
	        IF #enableStepTransition AND #cm_inPosition AND #em_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset:=NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	END_REGION
	
	REGION Actions
	    // NA
	    
	END_REGION
	
	REGION Control/Equipment Modules and Modes: Commands     
	    REGION Vacuum: Commands
	        CASE #step.actual OF
	            VacHop_Vent_Steps#INITIAL..VacHop_Vent_Steps#STOP_VACUUM_AND_CLOSE_OUTLET:
	                IF #em_vacuum_idle THEN
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	                ELSE
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#STOP_VACUUM;
	                END_IF;
	            ELSE
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	        END_CASE;
	        
	    END_REGION
	    
	    REGION Vacuum valve: Command
	        CASE #step.actual OF
	            VacHop_Vent_Steps#INITIAL..VacHop_Vent_Steps#STOP_VACUUM_AND_CLOSE_OUTLET:
	                IF NOT #em_outVlv_outletClose THEN
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#CLOSE_OUTLET;
	                ELSE
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                END_IF;
	            ELSE
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	        END_CASE;
	        
	    END_REGION
	    
	END_REGION
	
	REGION Control Modules: Commands 
	    //********************************************************
	    // Vent Valve
	    //********************************************************
	    #cmd_ventVlvOpen := #activate AND (NOT (#step.actual = VacHop_Vent_Steps#CLOSE_VENT_VALVE)) AND (NOT ((#step.actual = VacHop_Vent_Steps#DONE)));
	    
	    
	END_REGION
	
	REGION #feedbacks
	    // Update feedback statuses
	    #feedbacks.venting := (#step.actual = VacHop_Vent_Steps#OPEN_VENT_VALVE) OR (#step.actual = VacHop_Vent_Steps#VENT_DELAY_ACTIVE);
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when vent complete
	    #status.done := (NOT #status.idle) AND #cm_inPosition AND #em_idleOrDone AND (#step.actual = VacHop_Vent_Steps#DONE);
	                                    
	    // System busy during vent sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_OutVlv
FUNCTION_BLOCK EM_OutVlv
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := True;   // Enable step transition
      outletValveInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : OutVlv_inputs;   // EM inputs
   END_VAR

   VAR_OUTPUT 
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM in position
      cmd_outletVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command: outlet valve open
   END_VAR

   VAR 
      interface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : OutVlv_interface;
      parameters : OutVlv_parameters;
      _initialize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_OutVlv_initialize;
      _purge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_OutVlv_purge;
      _discharge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_OutVlv_discharge;
      _holdPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_OutVlv_holdPosition;
      _openOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_OutVlv_openOutlet;
      _closeOutlet { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_OutVlv_closeOutlet;
      _outputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         cmd_outletVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_VAR

   VAR_TEMP 
      temp_mode_idle_or_done : Bool;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_OutVlv Logic
	    // Description: 
	    // - Main controller for the outlet valvce system.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	            Author      Date        Change
	            GEA-VAR     15MAY25     Initial version
	        *)
	    END_REGION
	    
	END_REGION
	
	REGION Check CM/EM(mode) in position
	    // Set control module position status
	    #cm_inPosition :=
	        (#_outputs.cmd_outletVlvOpen AND #outletValveInputs.outletVlv_isOpen) OR
	        ((NOT #_outputs.cmd_outletVlvOpen) AND #outletValveInputs.outletVlv_isClosed);
	        
	    #temp_mode_idle_or_done :=
	        (#_openOutlet.status.idle OR #_openOutlet.status.done) AND
	        (#_closeOutlet.status.idle OR #_closeOutlet.status.done);
	        
	END_REGION
	
	REGION Initialize 
	    // Run initialization sequence 
	    #_initialize(enableStepTransition:=#enableStepTransition,
	                 activate:=(#interface.cmd = OutVlv_Cmd#INITIALIZE),
	                 cm_inPosition:=#cm_inPosition,
	                 mode_idleOrDone:=#temp_mode_idle_or_done);  
	     
	END_REGION
	
	REGION Purge 
	    REGION Parameters
	        // Configure parameters for the purge count
	        #_purge.parameters.startDelay := #parameters.fixed.purgeStartDelay;
	        #_purge.parameters.count := #parameters.fixed.purgeCount;
	        #_purge.parameters.outletVlvOpenDelay := #parameters.fixed.purgeOutletVlvOpenDelay;
	        #_purge.parameters.outletVlvCloseDelay := #parameters.fixed.purgeOutletVlvCloseDelay;
	        
	    END_REGION
	    
	    // Activate Purge sequence on command 
	    #_purge(enableStepTransition:=#enableStepTransition,
	            activate := (#interface.cmd = OutVlv_Cmd#PURGE),
	            cm_inPosition:=#cm_inPosition,
	            mode_idleOrDone:=#temp_mode_idle_or_done,
	            outletVlv_isOpen:=#outletValveInputs.outletVlv_isOpen);
	END_REGION
	
	REGION Discharge
	    // Configure parameters for the discharge mode
	    REGION Parameters
	        #_discharge.parameters.dischargeTime := #parameters.variable.dischargeTime;
	        
	    END_REGION
	    
	    // Activate Purge sequence on command
	    #_discharge(enableStepTransition:=#enableStepTransition,
	                activate := (#interface.cmd = OutVlv_Cmd#DISCHARGE),
	                cm_inPosition:=#cm_inPosition,
	                mode_idleOrDone:=#temp_mode_idle_or_done);
	END_REGION
	
	REGION Hold Position
	    // Configure parameters for the Hold Position mode
	    REGION Parameters
	        #_holdPosition.parameters.na := FALSE;
	        
	    END_REGION
	     
	    // Activate Hold Position sequence on command
	    #_holdPosition(enableStepTransition:=#enableStepTransition,
	                   activate := (#interface.cmd = OutVlv_Cmd#HOLD_POSITION),
	                   cm_inPosition := #cm_inPosition,
	                   mode_idleOrDone := #temp_mode_idle_or_done,
	                   outletVlv_isClosed:=#outletValveInputs.outletVlv_isClosed);
	END_REGION
	
	REGION Open Outlet
	    // Configure parameters for the open outlet delay
	    REGION Parameters
	        IF #_purge.cmd_modeOpenOutlet THEN
	            #_openOutlet.parameters.vlvOpenDelay := #_purge.parameters.outletVlvOpenDelay;
	        ELSE
	            #_openOutlet.parameters.vlvOpenDelay := #parameters.fixed.outletVlvOpenDelay;
	        END_IF;
	        
	    END_REGION
	     
	    // Activate Open Outlet sequence when commanded or required by initialization, purge, discharge or holdPosition
	    #_openOutlet(enableStepTransition:=#enableStepTransition,
	                 activate := (#interface.cmd = OutVlv_Cmd#OPEN_OUTLET) OR #_initialize.cmd_modeOpenOutlet OR #_purge.cmd_modeOpenOutlet OR #_discharge.cmd_modeOpenOutlet OR #_holdPosition.cmd_modeOpenOutlet,
	                 cm_inPosition:=#cm_inPosition,
	                 outletVlv_isOpen:=#outletValveInputs.outletVlv_isOpen);
	    
	END_REGION
	
	REGION Close Outlet 
	    // Configure parameters for the close outlet delay
	    REGION Parameters        
	        IF #_purge.cmd_modeCloseOutlet THEN
	            #_closeOutlet.parameters.vlvCloseDelay := #_purge.parameters.outletVlvCloseDelay;
	        ELSE
	            #_closeOutlet.parameters.vlvCloseDelay := #parameters.fixed.outletVlvCloseDelay;
	        END_IF;
	        
	    END_REGION
	    
	    // Activate Close Outlet sequence when commanded or required by initialization, purge, discharge or holdPosition
	    #_closeOutlet(enableStepTransition:=#enableStepTransition,
	                  activate := (#interface.cmd = OutVlv_Cmd#CLOSE_OUTLET) OR #_initialize.cmd_modeCloseOutlet OR #_purge.cmd_modeCloseOutlet OR #_discharge.cmd_modeCloseOutlet OR #_holdPosition.cmd_modeCloseOutlet,
	                  cm_inPosition:=#cm_inPosition,
	                  outletVlv_isOpen := #outletValveInputs.outletVlv_isOpen,
	                  outletVlv_isClosed := #outletValveInputs.outletVlv_isClosed);
	END_REGION
	
	
	REGION Outputs
	    // Combine valve commands from outlet sequences
	    #cmd_outletVlvOpen := #_outputs.cmd_outletVlvOpen := #_openOutlet.cmd_outletVlvOpen OR #_closeOutlet.cmd_outletVlvOpen;
	    
	END_REGION
	
	REGION Feedbacks
	    // Update mode feedbacks 
	    #interface.feedbacks.outletOpen := #outletValveInputs.outletVlv_isOpen;
	    #interface.feedbacks.openingOutlet := (NOT #outletValveInputs.outletVlv_isOpen) AND #cmd_outletVlvOpen;
	    #interface.feedbacks.outletClose := #outletValveInputs.outletVlv_isClosed;
	    #interface.feedbacks.closingOutlet := (NOT #outletValveInputs.outletVlv_isClosed) AND (#interface.cmd <> OutVlv_Cmd#IDLE) AND  (NOT #cmd_outletVlvOpen);
	    #interface.feedbacks.held := #_holdPosition.feedbacks.held;
	    
	    REGION Modes
	        #interface.feedbacks.modes.initialize := #_initialize.feedbacks;
	        #interface.feedbacks.modes.openOutlet := #_openOutlet.feedbacks;
	        #interface.feedbacks.modes.closeOutlet := #_closeOutlet.feedbacks;
	        #interface.feedbacks.modes.purge := #_purge.feedbacks;
	        #interface.feedbacks.modes.discharge := #_discharge.feedbacks;
	        #interface.feedbacks.modes.holdPosition := #_holdPosition.feedbacks;
	        
	    END_REGION
	    
	END_REGION
	
	
	REGION Check CM/EM(mode) in position
	    // Set control module position status
	    #cm_inPosition :=
	        (#_outputs.cmd_outletVlvOpen AND #outletValveInputs.outletVlv_isOpen) OR
	        ((NOT #_outputs.cmd_outletVlvOpen) AND #outletValveInputs.outletVlv_isClosed);
	        
	    // Check if modes are idle or done
	    #temp_mode_idle_or_done :=
	        (#_openOutlet.status.idle OR #_openOutlet.status.done) AND
	        (#_closeOutlet.status.idle OR #_closeOutlet.status.done);
	    
	END_REGION
	
	REGION Status
	    #interface.status.done := #_initialize.status.done OR #_purge.status.done OR #_discharge.status.done OR #_holdPosition.status.done OR 
	    ((NOT (#_initialize.status.busy OR #_purge.status.busy OR #_discharge.status.busy OR #_holdPosition.status.busy)) AND (#_openOutlet.status.done OR #_closeOutlet.status.done));
	    #interface.status.busy := #_initialize.status.busy OR #_openOutlet.status.busy OR #_closeOutlet.status.busy OR #_purge.status.busy OR #_discharge.status.busy;
	    #interface.status.idle := NOT (#interface.status.busy OR #interface.status.done);
	    #interface.status.stopAlmActive := _.EM.TODO.alm;
	    #interface.status.abortAlmActive := _.EM.TODO.alm;
	    
	    // Modes
	    #interface.modesStatus.initialize := #_initialize.status;
	    #interface.modesStatus.openOutlet := #_openOutlet.status;
	    #interface.modesStatus.closeOutlet := #_closeOutlet.status;
	    #interface.modesStatus.purge := #_purge.status;
	    #interface.modesStatus.discharge := #_discharge.status;
	    #interface.modesStatus.holdPosition := #_holdPosition.status;
	    
	END_REGION
	
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
FUNCTION_BLOCK EM_VacHop_discharge
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Discharge_Params;   // Discharge parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate discharge sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM in position
      em_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Idle or Done
      em_vacuum_idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM vacuum idle
      em_outVlv_outletClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM_OutVlv: outlet valve is closed
   END_VAR

   VAR_OUTPUT 
      cmd_em_vacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_Vac.Vac_Cmd;   // EM_Vac command
      cmd_em_outVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_OutVlv.OutVlv_Cmd;   // EM_OutVlv command
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Discharge_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Discharge_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Discharge_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_VacHop_discharge Logic
	    // Description: 
	    // - Manages the discharge sequence for the vacuum hopper, stopping vacuum and opening the outlet valve.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active   
	            VacHop_Discharge_Steps#INITIAL:
	                #_stepTracker.next := VacHop_Discharge_Steps#STOP_VACUUM;
	                
	                // Stop vacuum system  
	            VacHop_Discharge_Steps#STOP_VACUUM:
	                #_stepTracker.next := VacHop_Discharge_Steps#DISCHARGE;
	                
	                // Discharge product
	            VacHop_Discharge_Steps#DISCHARGE:
	                #_stepTracker.next := VacHop_Discharge_Steps#DONE;
	                
	                // Discharge sequence complete
	            VacHop_Discharge_Steps#DONE:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := VacHop_Discharge_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned
	        IF #enableStepTransition AND  #cm_inPosition AND #em_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset:=NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	END_REGION
	
	REGION Actions
	    // NA
	    
	END_REGION
	
	REGION Equipment Modules   
	    REGION Vacuum: Commands      
	        CASE #step.actual OF
	            VacHop_Discharge_Steps#INITIAL..VacHop_Discharge_Steps#STOP_VACUUM:
	                // Stop vacuum or wait for idle
	                IF #em_vacuum_idle THEN
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	                ELSE
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#STOP_VACUUM;
	                END_IF;
	            ELSE
	                // Maintain vacuum idle
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	        END_CASE;
	            
	    END_REGION
	    
	    REGION Outlet Valve: Command             
	        CASE #step.actual OF
	            VacHop_Discharge_Steps#INITIAL..VacHop_Discharge_Steps#STOP_VACUUM:
	                // Open outlet valve or wait for close
	                IF NOT #em_outVlv_outletClose THEN
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#OPEN_OUTLET;
	                ELSE
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                    
	                END_IF;
	                
	            VacHop_Discharge_Steps#DISCHARGE:
	                // Discharge outlet valve
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#DISCHARGE;
	                
	            ELSE
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                
	        END_CASE;
	        
	    END_REGION
	    
	END_REGION
	
	REGION Control Modules: Commands 
	    //********************************************************
	    // NA
	    //********************************************************
	    
	END_REGION
	
	
	REGION Feedbacks
	    // Update feedback statuses
	    #feedbacks.discharging := (#step.actual = VacHop_Discharge_Steps#DISCHARGE);
	    
	END_REGION
	
	//********************************************************
	// Region: #status Handling
	// Provides system status updates
	//********************************************************
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when discharge complete
	    #status.done := NOT #status.idle AND #cm_inPosition AND #em_idleOrDone AND (#step.actual = VacHop_Discharge_Steps#DONE);
	                                    
	    // System busy during discharge sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
FUNCTION_BLOCK EM_VacHop_initialize
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable step transition
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate initialize sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM/EM in position
      mode_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Mode idle or done
   END_VAR

   VAR_OUTPUT 
      cmd_em_vacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_Vac.Vac_Cmd;   // EM_Vac command
      cmd_em_outVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_OutVlv.OutVlv_Cmd;   // EM_OutVlv command
      cmd_modeVent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command vent mode
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Initialize_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Initialize_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Initialize_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_VacHop_initialize Logic
	    // Description: 
	    // - Manages the initialization sequence for the vacuum hopper, initializing vacuum and outlet valve, then venting.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active   
	            VacHop_Initialize_Steps#INITIAL:
	                #_stepTracker.next := VacHop_Initialize_Steps#INITIALIZE_VACUUM;
	                
	                // Initialize vacuum
	            VacHop_Initialize_Steps#INITIALIZE_VACUUM:
	                #_stepTracker.next := VacHop_Initialize_Steps#INITIALIZE_HOPPER;
	                
	                // Initialize hopper
	            VacHop_Initialize_Steps#INITIALIZE_HOPPER:
	                #_stepTracker.next := VacHop_Initialize_Steps#VENT;
	                
	                // Vent
	            VacHop_Initialize_Steps#VENT:
	                #_stepTracker.next := VacHop_Initialize_Steps#INITIALIZED;
	                
	                //  Initialization complete
	            VacHop_Initialize_Steps#INITIALIZED:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := VacHop_Initialize_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned/Idle or Done and transition is enable
	        IF #enableStepTransition AND #cm_inPosition AND #mode_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset := NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	    
	END_REGION
	
	REGION Control/Equipment Modules and Modes: Commands     
	    REGION Vacuum: Commands
	        CASE #step.actual OF
	            VacHop_Initialize_Steps#INITIALIZE_VACUUM:
	                // Initialize vacuum system
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#INITIALIZE;
	                
	            ELSE
	                // Maintain vacuum idle
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	                
	        END_CASE;
	        
	    END_REGION
	
	    REGION Outlet Valve: Command
	        CASE #step.actual OF
	            VacHop_Initialize_Steps#INITIALIZE_HOPPER:
	                // Initialize outlet valve
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#INITIALIZE;
	                
	            ELSE
	                // Maintain outlet valve idle
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                
	        END_CASE;
	        
	    END_REGION
	    
	    // Command vent mode
	    #cmd_modeVent := #step.actual = _.EM_VacHop.VacHop_Initialize_Steps#VENT;
	    
	END_REGION
	
	REGION Control Modules: Commands 
	    //********************************************************
	    // NA
	    //********************************************************
	    
	END_REGION
	
	REGION #feedbacks
	    // Update feedback statuses
	    #feedbacks.initialized :=  #cm_inPosition AND #mode_idleOrDone AND (#step.actual = VacHop_Initialize_Steps#INITIALIZED);
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated system is idle when inactive
	    #status.idle := NOT #activate;
	                                    
	    // System done when initialization complete
	    #status.done := NOT #status.idle AND #feedbacks.initialized;
	                                    
	    // System busy during initialization sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
FUNCTION_BLOCK EM_VacHop_hold
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Hold_Params;   // Hold parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate hold sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM in position
      em_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Idle or Done
      em_vacuum_idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Vacuum:  idle
   END_VAR

   VAR_OUTPUT 
      cmd_em_vacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_Vac.Vac_Cmd;   // EM_Vacuum: Command
      cmd_em_outVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_OutVlv.OutVlv_Cmd;   // EM_OutVlv: Command
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Hold_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Hold_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Hold_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_VacHop_hold Logic
	    // Description: 
	    // - Manages the hold sequence for the vacuum hopper, stopping vacuum and holding the last position of the outlet valve.
	    //********************************************************
	        
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active 
	            VacHop_Hold_Steps#INITIAL:
	                #_stepTracker.next := VacHop_Hold_Steps#STOP_VACUUM;
	                
	                // Stop vacuum system  
	            VacHop_Hold_Steps#STOP_VACUUM:
	                #_stepTracker.next := VacHop_Hold_Steps#HELD;
	                
	                // Hold position
	            VacHop_Hold_Steps#HELD:
	                #_stepTracker.next := VacHop_Hold_Steps#DONE;
	                
	                //  Hold sequence complete
	            VacHop_Hold_Steps#DONE:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := VacHop_Hold_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned
	        IF #enableStepTransition AND #cm_inPosition AND #em_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset := NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	END_REGION
	
	REGION Equipment Modules   
	    REGION Vacuum: Commands      
	        CASE #step.actual OF
	            VacHop_Hold_Steps#INITIAL..VacHop_Hold_Steps#STOP_VACUUM:
	                IF #em_vacuum_idle THEN
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	                ELSE
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#STOP_VACUUM;
	                END_IF;
	            ELSE
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	        END_CASE;
	        
	    END_REGION
	    
	    REGION Outlet Valve: Command     
	        CASE #step.actual OF
	            VacHop_Hold_Steps#RESET_STEP:
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                
	            ELSE:
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#HOLD_POSITION;
	                
	        END_CASE;
	                
	    END_REGION
	    
	END_REGION
	
	REGION Control Modules: Commands 
	    //********************************************************
	    // NA
	    //********************************************************
	    
	END_REGION
	
	REGION Feedbacks
	    // Update feedback statuses
	    #feedbacks.held := #cm_inPosition AND #em_idleOrDone AND (#step.actual = VacHop_Hold_Steps#HELD) OR (#step.actual = VacHop_Hold_Steps#DONE);
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when hold complete
	    #status.done := (NOT #status.idle) AND #cm_inPosition AND #em_idleOrDone AND (#step.actual = VacHop_Hold_Steps#DONE);
	                                    
	    // System busy during hold sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
FUNCTION_BLOCK EM_VacHop_purge
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Purge_Params;   // Purge parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate purge sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM in position
      em_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Idle or Done
      em_vacuum_idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Vacuum: Start Vacuum mode idle
      em_outVlv_outletClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM_OutVlv: outlet valve is closed
   END_VAR

   VAR_OUTPUT 
      cmd_em_vacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_Vac.Vac_Cmd;   // EM_Vac command
      cmd_em_outVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_OutVlv.OutVlv_Cmd;   // EM_OutVlv command
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_Purge_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Purge_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_Purge_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_VacHop_purge Logic
	    // Description: 
	    // - Manages the purge sequence for the vacuum hopper by opening the outlet valve to allow a burst of purge.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active
	            VacHop_Purge_Steps#INITIAL:
	                #_stepTracker.next := VacHop_Purge_Steps#STOP_VACUUM;
	                
	                // Stop vacuum system 
	            VacHop_Purge_Steps#STOP_VACUUM:
	                #_stepTracker.next := VacHop_Purge_Steps#PURGE;
	                
	                //  Purge hopper
	            VacHop_Purge_Steps#PURGE:
	                #_stepTracker.next := VacHop_Purge_Steps#DONE;
	                
	                //  Purge sequence complete
	            VacHop_Purge_Steps#DONE:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := VacHop_Purge_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned
	        IF #enableStepTransition AND #cm_inPosition AND #em_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset := NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	END_REGION
	
	
	REGION Equipment Modules   
	    REGION Vacuum: Commands      
	        CASE #step.actual OF
	            VacHop_Purge_Steps#INITIAL..VacHop_Purge_Steps#STOP_VACUUM:
	                // Stop vacuum or wait for idle
	                IF #em_vacuum_idle THEN
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	                ELSE
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#STOP_VACUUM;
	                END_IF;
	            ELSE
	                // Maintain vacuum idle
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	        END_CASE;
	        
	    END_REGION
	    
	    REGION Outlet Valve: Command             
	        CASE #step.actual OF
	            VacHop_Purge_Steps#INITIAL..VacHop_Purge_Steps#STOP_VACUUM:
	                // Close outlet valve or wait
	                IF NOT #em_outVlv_outletClose THEN
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#CLOSE_OUTLET;
	                ELSE
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                    
	                END_IF;
	                
	            VacHop_Purge_Steps#PURGE:
	                // Purge outlet valve
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#PURGE;
	                
	            ELSE
	                // Maintain outlet valve idle
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                
	        END_CASE;
	        
	    END_REGION
	    
	END_REGION
	
	REGION Control Modules: Commands 
	    //********************************************************
	    // NA
	    //********************************************************
	    
	END_REGION
	//********************************************************
	// Region: #Feedback Handling
	//********************************************************
	REGION Feedbacks
	    // na
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when purge complete
	    #status.done := (NOT #status.idle) AND #cm_inPosition AND #em_idleOrDone AND (#step.actual = VacHop_Purge_Steps#DONE);
	                                    
	    // System busy during purge sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
FUNCTION_BLOCK EM_VacHop_closeHopper
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Enable Step Transition
      parameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_CloseHopper_Params;   // Close hopper parameters
      activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate close sequence
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM in position
      em_idleOrDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Idle or Done
      em_vacuum_idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM Vacuum:  idle
      em_outVlv_outletClose { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // EM_Hopper: outlet valve is open
   END_VAR

   VAR_OUTPUT 
      cmd_em_vacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_Vac.Vac_Cmd;   // EM_Vac command
      cmd_em_outVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : _.EM_OutVlv.OutVlv_Cmd;   // EM_OutVlv command
   END_VAR

   VAR 
      status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_modeStatus;   // Mode status
      feedbacks { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_CloseHopper_Feedbacks;   // Feedbacks
      step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Util_Step;   // Step status
      _step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LIB.Step;   // Step instance
      _stepTracker { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_CloseHopper_Steps;   // Current step
         next { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_CloseHopper_Steps;   // Next step
      END_STRUCT;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_VacHop_closeHopper Logic
	    // Description: 
	    // - Manages the hopper outlet closing sequence for the vacuum hopper, stopping vacuum and closing the outlet valve.
	    //********************************************************
	    
	    REGION Revision History
	        (*
	        Author      Date        Change
	        GEA-VAR     2025-05-15  Initial version
	        *)
	    END_REGION
	END_REGION
	
	REGION Step 
	    IF #activate THEN
	        CASE #step.actual OF
	                // Idle state, no sequence active 
	            VacHop_CloseHopper_Steps#INITIAL:
	                #_stepTracker.next := VacHop_CloseHopper_Steps#STOP_VACUUM;
	                
	                // Stop vacuum system
	            VacHop_CloseHopper_Steps#STOP_VACUUM:
	                #_stepTracker.next := VacHop_CloseHopper_Steps#CLOSE_OUTLET;
	                
	                //  Close outlet valve
	            VacHop_CloseHopper_Steps#CLOSE_OUTLET:
	                #_stepTracker.next := VacHop_CloseHopper_Steps#DONE;
	                
	                //  Outlet valve closed, sequence complete
	            VacHop_CloseHopper_Steps#DONE:
	                ;
	                
	                // Handle invalid step
	            ELSE
	                // Reset to idle on invalid step
	                #step.actual := #_stepTracker.next := VacHop_CloseHopper_Steps#INITIAL;
	        END_CASE;
	        
	        // Advance step when module positioned
	        IF #enableStepTransition AND #cm_inPosition AND #em_idleOrDone THEN
	            #step.actual := #_stepTracker.next;
	        END_IF;
	        
	    END_IF;
	    
	    // Manage step transitions and reset
	    #_step(forceReset := NOT #activate,
	           step := #step);
	    #_stepTracker.actual := #step.actual;
	END_REGION
	
	REGION Control/Equipment Modules and Modes: Commands 
	    
	    REGION Vacuum: Commands        
	        CASE #step.actual OF
	            VacHop_CloseHopper_Steps#INITIAL..VacHop_CloseHopper_Steps#STOP_VACUUM:
	                // Stop vacuum or wait for idle
	                IF #em_vacuum_idle THEN
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	                ELSE
	                    #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#STOP_VACUUM;
	                END_IF;
	            ELSE
	                #cmd_em_vacuum := _.EM_Vac.Vac_Cmd#IDLE;
	        END_CASE;
	        
	    END_REGION
	    
	    REGION Outlet Valve: Command
	        CASE #step.actual OF
	            VacHop_CloseHopper_Steps#INITIAL..VacHop_CloseHopper_Steps#STOP_VACUUM:
	                IF NOT #em_outVlv_outletClose THEN
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#OPEN_OUTLET;
	                ELSE
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                END_IF;
	            VacHop_CloseHopper_Steps#CLOSE_OUTLET:
	                IF NOT #em_outVlv_outletClose THEN
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#CLOSE_OUTLET;
	                ELSE
	                    #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	                END_IF;
	            ELSE
	                // Maintain outlet valve closed
	                #cmd_em_outVlv := _.EM_outVlv.OutVlv_Cmd#IDLE;
	        END_CASE;
	        
	    END_REGION
	    
	END_REGION
	
	REGION Control Modules: Commands 
	    //********************************************************
	    // NA
	    //********************************************************
	    
	END_REGION
	
	REGION Feedbacks
	    // NA
	    
	END_REGION
	
	REGION Status
	    // System idle when not activated
	    #status.idle := NOT #activate;
	                                    
	    // System done when hopper closed
	    #status.done := (NOT #status.idle) AND #cm_inPosition AND #em_idleOrDone AND (#step.actual = VacHop_CloseHopper_Steps#DONE);
	                                    
	    // System busy during close sequence
	    #status.busy := NOT #status.idle AND NOT #status.done;
	                                    
	END_REGION
	
	                                        
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_Vac
FUNCTION_BLOCK EM_Vac
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := True;   // Enable step transition
      vacuumInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Vac_inputs;   // EM inputs
      emptyLine { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request empty line
   END_VAR

   VAR_OUTPUT 
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CM in position
      cmd_isolationVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to open isolation valve
      cmd_vacuumVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Command to open vacuum valve
      setpoint_vacuumControlVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Vacuum control valve setpoint
   END_VAR

   VAR 
      interface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Vac_interface;
      parameters : Vac_parameters;
      _initialize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_Vac_initialize;
      _startVacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_Vac_startVacuum;
      _stopVacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_Vac_stopVacuum;
      _outputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         cmd_isolationVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         cmd_vacuumVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_VAR

   VAR_TEMP 
      temp_modes_idle_or_done : Bool;   // excluding "Initialize mode"
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_Vac Logic
	    // Description: 
	    // - Main controller for the vacuum system, managing initialization, start, and stop sequences.
	    //********************************************************
	        
	    REGION Revision History
	        (*
	            Author      Date        Change
	            GEA-VAR     15MAY25     Initial version
	        *)
	    END_REGION
	        
	END_REGION
	    
	REGION Check CM/EM(mode) in position
	    // Set control module position status
	    #cm_inPosition :=
	        ((#_outputs.cmd_isolationVlvOpen AND #vacuumInputs.isolationVlv_isOpen) OR ((NOT #_outputs.cmd_isolationVlvOpen) AND #vacuumInputs.isolationVlv_isClosed)) AND
	        ((#_outputs.cmd_vacuumVlvOpen AND #vacuumInputs.vacuumVlv_isOpen) OR ((NOT #_outputs.cmd_vacuumVlvOpen) AND #vacuumInputs.vacuumVlv_isClosed));
	        
	    // Check if modes are idle or done
	    #temp_modes_idle_or_done :=
	        (#_startVacuum.status.idle OR #_startVacuum.status.done) AND
	        (#_stopVacuum.status.idle OR #_stopVacuum.status.done);
	    
	END_REGION
	 
	REGION Initialize
	    // Run initialization sequence
	    #_initialize(en_stepTrans:=#enableStepTransition,
	                 activate:=(#interface.cmd = Vac_Cmd#INITIALIZE),
	                 cm_inPosition:=#cm_inPosition,
	                 mode_idleOrDone:=#temp_modes_idle_or_done);
	     
	END_REGION
	
	REGION Start Vacuum
	    // Configure parameters for start sequence
	    REGION Parameters
	        #_startVacuum.parameters.minVacuumAirFlow := #parameters.fixed.vacuumMinAirFlow;
	        #_startVacuum.parameters.vacuumBuildUpTimer := #parameters.fixed.vacuumBuildUpTimer;
	        #_startVacuum.parameters.vacuumControlSP := #parameters.fixed.vacuumControlSP;
	        #_startVacuum.parameters.vacuumControlMinOpening := #parameters.fixed.vacuumControlMinOpening;
	        #_startVacuum.parameters.minTimeLineEmpty := #parameters.variable.minTimeLineEmpty;
	    END_REGION 
	    
	    // Activate start sequence on command
	    #_startVacuum(enableStepTransition:=#enableStepTransition,
	                  activate := (#interface.cmd = Vac_Cmd#START_VACUUM) OR #_initialize.cmd_modeStartVacuum,
	                  emptyLine:=#emptyLine,
	                  cm_inPosition:=#cm_inPosition,
	                  AHU_minAirflowReached := #vacuumInputs.AHU_minAirflowReached,
	                  vacuumAirflow_PV := #vacuumInputs.vacuumAirflow_PV);
	END_REGION
	
	REGION Stop Vacuum
	    // Configure parameters for stop sequence
	    REGION Parameters
	        #_stopVacuum.parameters.isolationVlvCloseDelay := #parameters.variable.isolationVlvCloseDelay;
	        #_stopVacuum.parameters.vacuumVlvCloseDelay := #parameters.fixed.vacuumVlvCloseDelay;
	        #_stopVacuum.parameters.vacuumControlSP := #parameters.fixed.vacuumControlSP;
	        #_stopVacuum.parameters.vacuumControlMinOpening := #parameters.fixed.vacuumControlMinOpening;
	        
	    END_REGION
	    
	    // Activate stop sequence on command
	    #_stopVacuum(enableStepTransition:=#enableStepTransition,
	                 activate := (#interface.cmd = Vac_Cmd#STOP_VACUUM) OR #_initialize.cmd_modeStopVacuum,
	                 cm_inPosition:=#cm_inPosition,
	                 vacuumVlv_isOpen := #vacuumInputs.vacuumVlv_isOpen,
	                 vacuumVlv_isClosed := #vacuumInputs.vacuumVlv_isClosed,
	                 isolationVlv_isOpen := #vacuumInputs.isolationVlv_isOpen,
	                 isolationVlv_isClosed := #vacuumInputs.isolationVlv_isClosed);
	    
	END_REGION
	
	REGION Outputs
	    // Aggregate valve commands
	    #cmd_isolationVlvOpen := #_outputs.cmd_isolationVlvOpen := #_startVacuum.cmd_isolationVlvOpen OR #_stopVacuum.cmd_isolationVlvOpen;
	    #cmd_vacuumVlvOpen := #_outputs.cmd_vacuumVlvOpen := #_startVacuum.cmd_vacuumVlvOpen OR #_stopVacuum.cmd_vacuumVlvOpen;
	    
	    // Select maximum setpoint for valve
	    #setpoint_vacuumControlVlv := MAX_REAL(IN1 := #_startVacuum.setpoint_vacuumControlVlv, IN2 := #_stopVacuum.setpoint_vacuumControlVlv);
	    
	END_REGION
	
	REGION Feedbacks
	    #interface.feedbacks.isolationVlvOpen := (NOT #_startVacuum.status.idle) AND #vacuumInputs.isolationVlv_isOpen;
	    // Update mode feedbacks
	    REGION Modes
	        #interface.feedbacks.modes.initialize := #_initialize.feedbacks;
	        #interface.feedbacks.modes.startVacuum := #_startVacuum.feedbacks;
	        #interface.feedbacks.modes.stopVacuum := #_stopVacuum.feedbacks;
	    END_REGION
	    
	END_REGION
	
	REGION Check CM/EM(mode) in position
	    // Set control module position status
	    #cm_inPosition :=
	    ((#_outputs.cmd_isolationVlvOpen AND #vacuumInputs.isolationVlv_isOpen) OR ((NOT #_outputs.cmd_isolationVlvOpen) AND #vacuumInputs.isolationVlv_isClosed)) AND
	    ((#_outputs.cmd_vacuumVlvOpen AND #vacuumInputs.vacuumVlv_isOpen) OR ((NOT #_outputs.cmd_vacuumVlvOpen) AND #vacuumInputs.vacuumVlv_isClosed));
	    
	    // Check if modes are idle or done
	    #temp_modes_idle_or_done := (#_startVacuum.status.idle OR #_startVacuum.status.done) AND (#_stopVacuum.status.idle OR #_stopVacuum.status.done);
	    
	    
	END_REGION
	
	REGION Status
	    // Set overall and mode statuses
	    #interface.status.done := #_initialize.status.done OR
	        ((NOT #_initialize.status.busy) AND (#_startVacuum.status.done OR #_stopVacuum.status.done));
	    #interface.status.busy := #_initialize.status.busy OR #_startVacuum.status.busy OR #_stopVacuum.status.busy OR (#interface.status.busy AND (NOT #cm_inPosition));
	    #interface.status.idle := (NOT (#interface.status.busy OR #interface.status.done)) AND #cm_inPosition AND #temp_modes_idle_or_done AND #_initialize.status.idle;
	    #interface.status.stopAlmActive := _.EM.TODO.alm;
	    #interface.status.abortAlmActive := _.EM.TODO.alm;
	    
	    // Modes
	    #interface.modesStatus.initialize := #_initialize.status;
	    #interface.modesStatus.startVacuum := #_startVacuum.status;
	    #interface.modesStatus.stopVacuum := #_stopVacuum.status;
	    
	END_REGION
	
END_FUNCTION_BLOCK
END_NAMESPACE

NAMESPACE EM_VacHop
FUNCTION_BLOCK EM_VacHop
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enableStepTransition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := True;   // Enable step transition
      vacHopInputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : VacHop_inputs;   // EM inputs
      emptyLine { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request empty line
   END_VAR

   VAR_OUTPUT 
      cm_inPosition { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      cmd_isolationVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      cmd_vacuumVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      cmd_vacuumControlVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      setpoint_vacuumControlVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
      cmd_outletVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      cmd_ventVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR 
      interface { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : VacHop_interface;
      parameters : VacHop_parameters;
      _em_vacuum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.EM_Vac.EM_Vac;   // EM Vacuum instance
      _em_outVlv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.EM_OutVlv.EM_OutVlv;   // EM Hopper instance
      _initialize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_VacHop_initialize;
      _discharge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_VacHop_discharge;
      _vent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_VacHop_vent;
      _openHopper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_VacHop_openHopper;
      _evacuate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_VacHop_evacuate;
      _flowThrough { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_VacHop_flowThrough;
      _purge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_VacHop_purge;
      _closeHopper { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : EM_VacHop_closeHopper;
      _hold { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : EM_VacHop_hold;
      _outputs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         cmd_ventVlvOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_VAR

   VAR_TEMP 
      temp_em_idle_or_done : Bool;
   END_VAR


BEGIN
	REGION Header
	    //********************************************************
	    // EM_VacHop Logic
	    // Description: Handles the Vacuum Hopper initialization process. The initialize block is activated
	    //********************************************************
	    
	    REGION Revision History
	        (*
	            Author      Date        Change
	            GEA-VAR     15MAY25     Initial version
	        *)
	    END_REGION
	    
	END_REGION
	
	REGION Check CM/EM(mode) in position
	    // Set control module position status
	    #cm_inPosition :=
	        #_em_vacuum.cm_inPosition AND #_em_outVlv.cm_inPosition AND 
	        ((#_outputs.cmd_ventVlvOpen AND #vacHopInputs.ventVlv_isOpen) OR ((NOT #_outputs.cmd_ventVlvOpen) AND #vacHopInputs.ventVlv_isClosed));
	        
	    // Check if modes are idle or done
	    #temp_em_idle_or_done :=
	        (#_em_vacuum.interface.status.idle OR #_em_vacuum.interface.status.done) AND
	        (#_em_outVlv.interface.status.idle OR #_em_outVlv.interface.status.done);
	     
	END_REGION
	
	REGION Initialize
	    #_initialize(enableStepTransition:=#enableStepTransition,
	                 activate:=(#interface.cmd = VacHop_Cmd#INITIALIZE),
	                 cm_inPosition:=#cm_inPosition,
	                 mode_idleOrDone:=#temp_em_idle_or_done);
	      
	END_REGION
	
	REGION Discharge
	    REGION Parameters
	        #_discharge.parameters.na := FALSE;
	        
	    END_REGION
	     
	    #_discharge(enableStepTransition:=#enableStepTransition,
	                activate:=(#interface.cmd = VacHop_Cmd#DISCHARGE),
	                cm_inPosition:=#cm_inPosition,
	                em_idleOrDone:=#temp_em_idle_or_done,
	                em_vacuum_idle:=#_em_vacuum.interface.status.idle,
	                em_outVlv_outletClose:=#vacHopInputs.em_outVlv_inputs.outletVlv_isClosed);
	    
	END_REGION
	
	REGION Vent
	    REGION Parameters
	        #_vent.parameters.ventTime := #parameters.fixed.ventTime;
	        
	    END_REGION
	     
	    #_vent(enableStepTransition:=#enableStepTransition,
	           activate:=(#interface.cmd = VacHop_Cmd#VENT) OR #_initialize.cmd_modeVent,
	           cm_inPosition:=#cm_inPosition,
	           em_idleOrDone:=#temp_em_idle_or_done,
	           em_vacuum_idle:=#_em_vacuum.interface.status.idle,
	           em_outVlv_outletClose:=#vacHopInputs.em_outVlv_inputs.outletVlv_isClosed);
	    
	END_REGION
	
	REGION Open Hopper
	    REGION Parameters
	        #_openHopper.parameters.na := FALSE;
	        
	    END_REGION
	     
	    #_openHopper(enableStepTransition:=#enableStepTransition,
	                 activate := (#interface.cmd = VacHop_Cmd#OPEN_HOPPER),
	                 cm_inPosition:=#cm_inPosition,
	                 em_idleOrDone:=#temp_em_idle_or_done,
	                 em_vacuum_idle:=#_em_vacuum.interface.status.idle,
	                 em_outVlv_outletClose := #vacHopInputs.em_outVlv_inputs.outletVlv_isClosed);
	       
	END_REGION
	
	REGION Evacuate
	    REGION Parameters
	        #_evacuate.parameters.na := FALSE;
	        
	    END_REGION
	     
	    #_evacuate(enableStepTransition:=#enableStepTransition,
	               activate := (#interface.cmd = VacHop_Cmd#EVACUATE),
	               cm_inPosition:=#cm_inPosition,
	               em_idleOrDone:=#temp_em_idle_or_done,
	               em_vacuum_startVacuum_idle:=#_em_vacuum.interface.modesStatus.startVacuum.idle,
	               em_outVlv_outletClose := #vacHopInputs.em_outVlv_inputs.outletVlv_isClosed);
	    
	END_REGION
	
	REGION Flowthrough
	    REGION Parameters
	        #_flowThrough.parameters.na := FALSE;
	        
	    END_REGION
	     
	    // Activate stop logic when STOP_VACUUM command is issued or initialize requires it
	    #_flowThrough(activate := (#interface.cmd = VacHop_Cmd#FLOWTHROUGHT),
	                  cm_inPosition:=#cm_inPosition,
	                  em_idleOrDone:=#temp_em_idle_or_done,
	                  em_vacuum_startVacuum_idle:=#_em_vacuum.interface.modesStatus.startVacuum.idle,
	                  em_outVlv_outletClose := #vacHopInputs.em_outVlv_inputs.outletVlv_isClosed);
	    
	END_REGION
	
	REGION Purge
	    REGION Parameters
	        #_purge.parameters.na := FALSE;
	        
	    END_REGION
	    
	    #_purge(enableStepTransition:=#enableStepTransition,
	            activate := (#interface.cmd = VacHop_Cmd#PURGE),
	            cm_inPosition:=#cm_inPosition,
	            em_idleOrDone:=#temp_em_idle_or_done,
	            em_vacuum_idle:=#_em_vacuum.interface.status.idle,
	            em_outVlv_outletClose := #vacHopInputs.em_outVlv_inputs.outletVlv_isClosed);
	END_REGION
	
	REGION Close Hopper
	    REGION Parameters
	        #_closeHopper.parameters.na := FALSE;
	        
	    END_REGION
	    
	    #_closeHopper(enableStepTransition:=#enableStepTransition,
	                  activate := (#interface.cmd = VacHop_Cmd#CLOSE_HOPPER),
	                  cm_inPosition := #cm_inPosition,
	                  em_idleOrDone := #temp_em_idle_or_done,
	                  em_vacuum_idle := #_em_vacuum.interface.status.idle,
	                  em_outVlv_outletClose := #vacHopInputs.em_outVlv_inputs.outletVlv_isClosed);
	   
	END_REGION
	
	REGION Hold
	    REGION Parameters
	        #_hold.parameters.na := FALSE;
	        
	    END_REGION
	    
	    #_hold(enableStepTransition:=#enableStepTransition,
	           activate := (#interface.cmd = VacHop_Cmd#HOLD),
	           cm_inPosition := #cm_inPosition,
	           em_idleOrDone := #temp_em_idle_or_done,
	           em_vacuum_idle := #_em_vacuum.interface.status.idle);
	    
	END_REGION
	
	
	//********************************************************
	// Region: Command Mapping
	//********************************************************
	REGION Commands
	    REGION Equipment Modules
	        REGION Vacuum
	            REGION Parameters
	                // Fixed
	                #_em_vacuum.parameters.fixed := #parameters.fixed.em_vac;
	                
	                // Variable
	                #_em_vacuum.parameters.variable.isolationVlvCloseDelay := #parameters.fixed.isolationVlvCloseDelay;
	                #_em_vacuum.parameters.variable.minTimeLineEmpty := #parameters.variable.transferLineEmptyTime;
	                
	            END_REGION
	            
	            
	            REGION Control/Command
	                #_em_vacuum.interface.cmd := MAX_USINT(IN1 := #_initialize.cmd_em_vacuum,
	                                                       IN2 := #_discharge.cmd_em_vacuum,
	                                                       IN3 := #_vent.cmd_em_vacuum,
	                                                       IN4 := #_openHopper.cmd_em_vacuum,
	                                                       IN5 := #_evacuate.cmd_em_vacuum,
	                                                       IN6 := #_flowThrough.cmd_em_vacuum,
	                                                       IN7 := #_purge.cmd_em_vacuum,
	                                                       IN8 := #_closeHopper.cmd_em_vacuum,
	                                                       IN9 := #_hold.cmd_em_vacuum);
	            END_REGION
	            
	            #_em_vacuum(enableStepTransition:=#enableStepTransition,
	                        vacuumInputs:=#vacHopInputs.em_vac_inputs,
	                        emptyLine:=#emptyLine,
	                        cmd_isolationVlvOpen=>#cmd_isolationVlvOpen,
	                        cmd_vacuumVlvOpen=>#cmd_vacuumVlvOpen,
	                        setpoint_vacuumControlVlv=>#setpoint_vacuumControlVlv);
	            
	        END_REGION
	        
	        REGION Hopper
	            REGION Parameters
	                // Fixed
	                #_em_outVlv.parameters.fixed := #parameters.fixed.em_outVlv;
	                
	                // Variable
	                #_em_outVlv.parameters.variable.dischargeTime := #parameters.fixed.dischargeTime;
	                
	            END_REGION
	            
	            REGION Control/Command
	                #_em_outVlv.interface.cmd := MAX_USINT(IN1 := #_initialize.cmd_em_outVlv,
	                                                       IN2 := #_discharge.cmd_em_outVlv,
	                                                       IN3 := #_vent.cmd_em_outVlv,
	                                                       IN4 := #_openHopper.cmd_em_outVlv,
	                                                       IN5 := #_evacuate.cmd_em_outVlv,
	                                                       IN6 := #_flowThrough.cmd_em_outVlv,
	                                                       IN7 := #_purge.cmd_em_outVlv,
	                                                       IN8 := #_closeHopper.cmd_em_outVlv,
	                                                       IN9 := #_hold.cmd_em_outVlv);
	            END_REGION
	            
	            #_em_outVlv(enableStepTransition:=#enableStepTransition,
	                        outletValveInputs:=#vacHopInputs.em_outVlv_inputs,
	                        cmd_outletVlvOpen=>#cmd_outletVlvOpen);
	            
	        END_REGION
	        
	    END_REGION
	    
	    REGION Control Modules
	        #cmd_ventVlvOpen := #_outputs.cmd_ventVlvOpen := #_vent.cmd_ventVlvOpen;
	        
	    END_REGION
	END_REGION
	
	
	REGION Feedbacks
	    #interface.feedbacks.transferLineEmpty := #interface.feedbacks.em_vacuum.modes.startVacuum.minTimeLineEmptyReached;
	    
	    REGION Modes
	        #interface.feedbacks.modes.initialize := #_initialize.feedbacks;
	        #interface.feedbacks.modes.discharge := #_discharge.feedbacks;
	        #interface.feedbacks.modes.vent := #_vent.feedbacks;
	        #interface.feedbacks.modes.openHopper := #_openHopper.feedbacks;
	        #interface.feedbacks.modes.evacuate := #_evacuate.feedbacks;
	        #interface.feedbacks.modes.flowThrough := #_flowThrough.feedbacks;
	        #interface.feedbacks.modes.purge := #_purge.feedbacks;
	        #interface.feedbacks.modes.closeHopper := #_closeHopper.feedbacks;
	        #interface.feedbacks.modes.hold := #_hold.feedbacks;
	        
	    END_REGION
	    
	    REGION Equipment Modules
	        #interface.feedbacks.em_vacuum := #_em_vacuum.interface.feedbacks;
	        #interface.feedbacks.em_hopper := #_em_outVlv.interface.feedbacks;
	        
	    END_REGION
	    
	    
	END_REGION
	
	
	REGION Check CM/EM(mode) in position
	    // Set control module position status
	    #cm_inPosition := #_em_vacuum.cm_inPosition AND #_em_outVlv.cm_inPosition AND
	        ((#_outputs.cmd_ventVlvOpen AND #vacHopInputs.ventVlv_isOpen) OR ((NOT #_outputs.cmd_ventVlvOpen) AND #vacHopInputs.ventVlv_isClosed));
	    
	    // Check if modes are idle or done
	    #temp_em_idle_or_done :=
	        (#_em_vacuum.interface.status.idle OR #_em_vacuum.interface.status.done) AND
	        (#_em_outVlv.interface.status.idle OR #_em_outVlv.interface.status.done);
	    
	END_REGION
	
	REGION Status
	    #interface.status.done :=
	        #_initialize.status.done OR #_discharge.status.done OR #_openHopper.status.done OR #_evacuate.status.done OR #_flowThrough.status.done OR #_purge.status.done OR #_closeHopper.status.done OR #_hold.status.done OR
	        ((NOT #_initialize.status.busy) AND #_vent.status.done);
	    #interface.status.busy :=
	        #_initialize.status.busy OR #_discharge.status.busy OR #_vent.status.busy OR #_openHopper.status.busy OR #_evacuate.status.busy OR #_flowThrough.status.busy OR #_purge.status.busy OR #_closeHopper.status.busy OR #_hold.status.busy;
	    #interface.status.idle := NOT (#interface.status.busy OR #interface.status.done);
	    #interface.status.stopAlmActive := _.EM.TODO.alm;
	    #interface.status.abortAlmActive := _.EM.TODO.alm;
	    
	    // Modes
	    #interface.modesStatus.initialize := #_initialize.status;
	    #interface.modesStatus.discharge := #_discharge.status;
	    #interface.modesStatus.vent := #_vent.status;
	    #interface.modesStatus.openHopper := #_openHopper.status;
	    #interface.modesStatus.evacuate := #_evacuate.status;
	    #interface.modesStatus.flowThrough := #_flowThrough.status;
	    #interface.modesStatus.purge := #_purge.status;
	    #interface.modesStatus.closeHopper := #_closeHopper.status;
	    #interface.modesStatus.hold := #_hold.status;
	    
	END_REGION
	
END_FUNCTION_BLOCK
END_NAMESPACE

